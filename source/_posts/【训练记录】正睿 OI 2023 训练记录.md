---
title: 【训练记录】正睿 OI 2023 训练记录

date: 2023-01-03 16:46:29

description: 本文为正睿 OI 2023 的训练记录。

non-public: true

katex: true

tags:

- 训练记录
 
categories: 

- OI

- 正睿 OI

sticky: 1

cover: /img/13.png

---

## 前言

本文为笔者在正睿 OI 2023 中的训练记录，分为听课记录和模拟赛总结，前者包含听课笔记和已经理解了的题目的题解，后者包含考试总结和已经理解了的考试题的题解。

------

## 听课记录

### Day 2 2023.1.1 计数

#### 笔记

- 对于一个 $n$ 个节点的树，设以点 $u$ 为根的子树大小为 $si_u$，现给节点 $u$ 赋以权值 $p_u$，满足 $p_{1 \sim n}$ 构成 $1\sim n$ 的一个排列，且对于每条边而言，父亲节点的权值小于儿子节点的权值，这样的赋权方案数为 $\displaystyle n! \prod_{i = 1}^n\frac{1}{si_u}$。
- 对于一个 $1 \sim n$ 的排列 $p_{1 \sim n}$，现限制 $\forall i \in[1, n], p_i \in[1, r_i]$，这样的排列数为 $\displaystyle \prod_{i = 1}^n (r_i' - i + 1)$，其中 $r_i'$ 表示将 $r_i$ 从小到大排序后形成的新序列。

------

#### 题目

- [AGC060C Large Heap](https://atcoder.jp/contests/agc060/tasks/agc060_c)

题解：

{% note success flat %}

考虑将左右两条链归并，把原来在左边的点称为 $1$ 类点，原来在右边的点称为 $2$ 类点。

那么根据归并后链的尾部是 $1$ 类点还是 $2$ 类点，我们就可以知道 $p_u$ 和 $p_v$ 的大小关系。

考虑设 $f_{i, j}$ 表示左侧归并了 $i$ 个点，右侧归并了 $j$ 个点的方案数，转移方程显然。

转移的最后，我们考虑统计最后归并的是 $1$ 类点的方案数 $val_1$ 和是 $2$ 类点的方案数 $val_2$，那么答案即为 $\displaystyle \frac{val_2}{val_1 +val_2}$。

[代码实现](https://atcoder.jp/contests/agc060/submissions/37736351)

{% endnote %}

------

- [AGC060D Same Descent Set](https://atcoder.jp/contests/agc060/tasks/agc060_d)

题解：

{% note success flat %}

考虑枚举大于号的位置集合 $S$，设 $f_S$ 表示其方案数，那么答案即为 $\displaystyle \sum_S f_S^2$。

对于这种问题，直接做必然是很困难的，我们考虑容斥，设 $g_S$ 表示大于号集合是 $S$ 的超集的方案数，那么答案为 $\displaystyle \sum_S(\sum_{S \subseteq T} (-1)^{|T|-|S|} \cdot g_T)^2$。

把后面的平方式拆开，改变一下枚举顺序就有 $\displaystyle \sum_{T_1, T_2} (-1)^{|T_1| + |T_2|} \cdot g_{T_1}\cdot g_{T_2} \cdot 2^{|T_1\cap T_2|}$。

我们发现 $2^{|T_1\cap T_2|}$ 比较难搞，不妨把它拆开，变成 $2^{|T_1|+|T_2| - (n - 1) + |\overline{T_1} \cap \overline{T_2} |}$，那么原式可以化为 $\displaystyle \frac{1}{2^{n - 1}}\sum_{T_1, T_2} ((-2)^{|T_1|} \cdot g_{T_1})\cdot ((-2)^{|T_2|} \cdot g_{T_2}) \cdot 2^{|\overline{T_1}\cap \overline{T_2}|}$。

接下来我们考察 $\overline{T_1}\cap \overline{T_2}$ 的意义：它表示两个集合均为 $0$ 的位置，也就是均未被钦定为大于号的位置。注意到这些位置把整个序列分为了若干段，每一段都不存在两个集合均为 $0$ 的位置，那么 $2^{|\overline{T_1}\cap \overline{T_2}|}$ 这个部分可以贡献到每一段上，最后再乘上一个 $\displaystyle \frac{1}{2}$ 的系数，我们不妨将这个系数提到外面。

我们设一段的方案数的 $\mathcal{OGF}$ 为 $G(x)$（注意其常数项为 $0$），设总的方案数的 $\mathcal{OGF}$ 为 $F(x)$，这样原式就变为了 $\displaystyle \frac{1}{2^{n}} \cdot [x^n]F(x)$。

通过二者的关系，我们可以得出 $\displaystyle F(x) = \frac{1}{1 - 2\cdot G(x)}$。那么，只要我们求出求出了 $G(x)$，就可以通过多项式求逆求出 $F(x)$，进而求出答案。

接下来我们考察 $g_S$ 的意义。

注意到连续的一段大于号会确定对应的连续的一段位置的大小关系，因此 $g_S$ 可以表示为 $\displaystyle \frac{n!}{\displaystyle \prod_{i = 1}^m l_i!}$ 的形式，我们不妨将 $n!$ 这个系数提到外面去。

至于前面的系数 $(-2)^{|T_1|}$，我们考虑设段的长度为 $m$，那么原式中的 $(-2)^{|T_1|} \cdot g_{T_1}$ 就可以转化为 $\displaystyle \frac{(-2)^m}{\displaystyle \prod_{i = 1}^{m - |T_1|} (-2 \cdot l_i!)}$。

现在我们设 $H(x)$ 表示一段的方案数的 $\mathcal{OGF}$（注意其常数项也为 $0$），但没有 “不存在两个集合均为 $0$ 的位置” 这个限制。

根据上文 $g_S$ 的意义，设 $\displaystyle I(x) =\frac{1}{\displaystyle 1 + \frac{1}{2} \cdot (e^x - 1)}$，那么其第 $m$ 项的系数为 $\displaystyle ((-2)^m \cdot [x^m]I(x))^2$。

最后，我们可以得出，$G(x)$ 和 $H(x)$ 存在关系 $H(x) = G(x) \cdot (H(x) +1)$，转化一下式子可得 $\displaystyle G(x) = \frac{H(x)}{H(x)+1}$，这样我们就可以得出答案了。

[代码实现](https://atcoder.jp/contests/agc060/submissions/37765734)

{% endnote %}

------

- [AGC059C Guessing Permutation for as Long as Possible](https://atcoder.jp/contests/agc059/tasks/agc059_c)

题解：

{% note success flat %}

对于三个下标 $i, j, k$ 而言，若最后一组询问为 $(i, k)$，说明 $p_j$ 是 $p_i, p_j, p_k$ 三者中的极值。

此时会存在两组等价关系：$p_i < p_j \Leftrightarrow p_j >p_k$ 和 $p_i >p_j \Leftrightarrow p_j < p_k$。那么我们可以对形如 $p_i < p_j$ 的关系建图，然后通过上述结论连边。

可以发现，这样连出来的图是对称的，每个连通块都会与另外一个连通块唯一对应。

对于一个连通块而言，我们仅需知道其中一组关系的真假性，就可以知道它和它对应的另一个连通块内所有关系的真假性。

确定了 $\displaystyle \frac{n \cdot (n - 1)}{2}$ 组关系之后，我们就能够唯一确定这个排列了。所以，设连通块个数为 $m$，则答案为 $2^{\frac{m}{2}}$。

[代码实现](https://atcoder.jp/contests/agc059/submissions/37699598)

{% endnote %}

------

- [AGC054C Roughly Sorted](https://atcoder.jp/contests/agc054/tasks/agc054_c)

题解：

{% note success flat %}

对于一个不合法的排列而言，要使得操作次数最小，就要保证每次操作都会减小一组逆序对。

那么，我们可以考虑从给定的排列出发，进行若干次操作，满足每次操作过后，排列都是不合法的，且都会增加一组逆序对。

设 $cnt_i = \displaystyle \sum_{j = 1}^{i - 1} [p_j >p_i]$，那么要满足第一个要求，我们就必须移动 $cnt_i$ 恰好为 $k$ 的位置 $i$，要满足第二个要求，我们就必须移动满足 $p_i >p_{i +1}$ 的位置 $i$ 。

注意到对于满足第一个要求的 $i$，它的后面一定不存在比它小的位置，否则这个比它小的位置的 $cnt_i$ 一定会大于 $k$。

那么，每个满足第一个要求的 $i$ 都可以向后移动最多 $n - i$ 次，并且这些位置的每一种移动次数的组合都会对应唯一的最初排列。

综上所属，设合法的位置为 $q_{1 \sim m}$，那么答案即为 $\displaystyle \prod_{i = 1}^m (n - q_i + 1)$。注意可能不存在合法的位置，此时答案为 $1$。

[代码实现](https://atcoder.jp/contests/agc054/submissions/37693812)

{% endnote %}

------

- [AGC043D Merge Triplets](https://atcoder.jp/contests/agc043/tasks/agc043_d)

题解：

{% note success flat %}

考虑对于一个位置 $i$ 而言，若 $p_i >p_{i +1}$，说明 $p_i$ 和 $p_{i +1}$ 必然在同一个段内。

也就是说，合法的排列不会存在长度超过 $3$ 的单调下降的子段。我们得出了一个必要条件。

那么，我们可以考虑通过前缀 $\max$ 的值将合法的排列分为若干块，每一块的长度都不超过 $3$。

现在我们需要将这些段组合为 $n$ 个长度为 $3$ 的段，那么长度为 $3$ 的块可以自成一段，长度为 $2$ 的块只能和长度为 $1$ 的块组合为一段，长度为 $1$ 的块可以和另外两个长度为 $1$ 的块组合为一段。这样，我们得出了一个充分条件 —— 长度为 $1$ 的块的数量一定不能少于长度为 $2$ 的块的数量。

接下来我们考虑讨论一下这些块对答案的贡献。由于每个块的第一个位置必然是前缀的最大值，因此，若所有块的右端点分别为 $q_{1\sim m}$，则总的方案数为 $\displaystyle \frac{n!}{\displaystyle \prod_{i = 1}^m q_i}$。

到了这里，我们就可以考虑 $\mathcal{DP}$ 了—— 设 $f_{i, j}$ 表示考虑 $1 \sim i$ 这些数，长度为 $1$ 的块的数量减去长度为 $2$ 的块的数量等于 $j$ 的方案数，转移考虑在排列尾部增添一个长度不超过 $3$ 的块，然后乘上相应的贡献系数即可。

[代码实现](https://atcoder.jp/contests/agc043/submissions/37704274)

{% endnote %}

------

- [AGC039E Pairing Points](https://atcoder.jp/contests/agc039/tasks/agc039_e)

题解：

{% note success flat %}

下设 $n$ 为题目中的 $N \cdot 2$。

考虑与点 $1$ 相连的点，设其为点 $i$，那么为了使连出来的图形成一棵树，在 $[2, n]$ 这个区间内，我们需要在 $[2, i)$ 内从左往右选出若干个点 $p_{1 \sim m}$，，在 $(i, n]$ 内从右往左选出若干个点 $q_{1 \sim m}$，使得对于所有 $j \in [1, m]$，点 $p_j$ 与点 $q_j$ 相连，然后再将剩下的点在两个区间内部相连。

这样，不妨设 $f_{l, r, i}$ 表示在区间 $[l, r]$ 内连边，其中只有点 $i$ 向区间外连边的方案数。最终的答案即为 $\displaystyle \sum_{i = 2}^{n}f_{2, n, i}$。

考虑转移，我们枚举分居 $i$ 的两侧的两点 $j, k$，令它们之间连一条边。对于区间 $(j, i)$，可以发现必然存在一个分界点 $p$，满足 $(j, p]$ 内的点的连边会与 $j$ 的连边相交，$(p, i)$ 内的点的连边会与 $i$ 的连边相交，区间 $(i, k)$ 同理存在一个分界点 $q$。

根据上述分析，我们有转移：
$$
f_{l, r, i} = \sum_{j = l}^{i - 1}\sum_{k = i +1}^{r}[a_{j, k} = 1]\sum_{p = j}^{i - 1}\sum_{q = i+1}^{k}f_{l, p, j} \cdot f_{p+1, q - 1, i} \cdot f_{q, r, k }
$$
边界条件为对于所有 $i \in [2, n]$，$f_{i, i, i} = 1$。

这样我们就得到了一个 $\mathcal{O}(n^7)$ 的做法，不过带了一个十分小的常数。

考虑优化。我们不妨交换枚举顺序：
$$
f_{l, r, i} = \sum_{p = l}^{i - 1}\sum_{q = i+ 1}^{r} f_{p+1, q - 1, i} \sum_{j = l}^{p}\sum_{k = q}^{r}[a_{j, k} = 1] \cdot f_{l, p, j} \cdot f_{q, r, k }
$$
可以发现枚举了 $p, q$ 后，后面的一部分都和 $i$ 没有关系了，那么我们不妨先枚举 $l, r$，再枚举 $p, q$，把后面这一部分算出来之后再枚举 $i$。

如何求后面这一部分呢？我们设 $\displaystyle g_{l, p, k} = \sum_{j = l}^{p}[a_{j, k}=1]\cdot f_{l, p, j}$，那么这一个部分就等于 $\displaystyle\sum_{k = q}^{r}g_{l, p, k} \cdot f_{q, r, k}$，我们在枚举了 $p, q$ 之后再计算即可。

这样时间复杂度就降至了 $\mathcal{O}(n^5)$。

[代码实现](https://atcoder.jp/contests/agc039/submissions/37767169)

{% endnote %}

------

- [AGC036F Square Constraints](https://atcoder.jp/contests/agc036/tasks/agc036_f)

题解：

{% note success flat %}

对于 $[0, n)$ 内的所有位置 $i$，它们具有限制 $p_i \in [l_i, r_i]$，而对于 $[n, n\cdot 2)$ 内的所有位置 $i$，它们具有限制 $p_i \in [0, r_i]$，其中涉及到的所有 $l_i, r_i$ 均为正整数。

考虑容斥 $[0, n)$ 内的所有位置，设容斥集合 $S$，那么 $S$ 内的所有位置 $i$ 的限制为 $p_i \in [0, l_i)$，$S$ 外的所有位置 $i$ 的限制为 $p_i \in [0, r_i]$，我们统一记为 $a_i$。

我们可以考虑按照限制从小到大做 $\mathcal{DP}$，设 $f_{i, j}$ 表示枚举了前 $i$ 个限制，其中有 $j$ 个位置在 $S$ 内。

转移时，对于 $[n, n\cdot 2)$ 内的所有位置，由于它们不会被容斥，因此它们的贡献是好算的，而对于 $[0, n)$ 内的所有位置，若它们在 $S$ 内，它们的贡献也可以通过 $j$ 算出，但如果它们不在 $j$ 内，我们就必须引入 $|S|$ 这个量才能算出它的贡献。

这样的话，我们可以考虑在外层枚举 $|S|$，内层做这个 $\mathcal{O}(n^2)$ 的 $\mathcal{DP}$，然后将 $(-1)^{|S|} \cdot f_{n\cdot2, |S|}$ 这个贡献加入答案中，总的时间复杂度为 $\mathcal{O}(n^3)$。

[代码实现](https://atcoder.jp/contests/agc036/submissions/37788682)

{% endnote %}

------

- [AGC035E Develop](https://atcoder.jp/contests/agc035/tasks/agc035_e)

题解：

{% note success flat %}

对于一种合法的删数方案，若同时存在 $x$ 和 $x - 2$，则 $x$ 必然会先删，否则 $x - 2$ 被删之后，$x$ 被删又会导致其重新被加入集合中，$x$ 和 $x + k$ 是同理的。

考虑对 $1\sim n$ 这些数建有向图，对于每个 $x$，连边 $x\rightarrow x - 2$ 和 $x \rightarrow x + k$（下文分别称为 $1$ 类边和 $2$ 类边），表示删边顺序，那么对于一个删数集合，若不存在环，我们就可以按照拓扑序删数，这说明合法的充要条件是删数集合所对应的导出子图不存在环。

若 $k$ 为偶数，可以发现奇数和偶数两个部分是独立的，这里我们仅考虑奇数的情况，可以发现奇数的图中仅会存在形如 $x \rightarrow x-2 \rightarrow \cdots \rightarrow x - k \rightarrow x$，那么唯一的限制就是不能删除连续的 $\displaystyle \frac{k}{2} +1$ 个奇数，我们随便 $\mathcal{DP}$ 一下即可。

若 $k$ 为奇数，可以发现如果存在环，那么环一定能够拆成若干简单环，而简单环一定会走恰好两条横跨奇数和偶数两个部分的边，也即 $2$ 类边，那么我们仅需限制图中不存在简单环即可。

考虑对于点 $x$，如果它能够成简单环，那么一定是一个形如 $x \rightarrow x - 2 \rightarrow \cdots y - k \rightarrow y \rightarrow y - 2 \cdots \rightarrow x - k \rightarrow x$ 的环，即先不断走 $1$ 类边，再走一条 $2$ 类边，再不断走 $1$ 类边，最后走回点 $x$。

我们不妨考虑维护这样的一条路径，它要求尽可能地在被删点的集合中走一条 $2$ 类边，并且在满足前者的情况下尽可能地向左侧延伸，这样是为了及时判断成环的情况。记以点 $x$ 作为起点的这条路径为 $path_x$，其最远能够到达 $to_x$，我们可以考虑将后者放入 $\mathcal{DP}$ 状态中，这样遇到会成环的情况我们就能够及时规避。

设 $f_{i, a, b}$ 表示考虑点 $1 \sim i$，且满足 $to_i = a, to_{i - 1} = b$ 的删点集合的方案数，记录 $b$ 这一维是为了方便转移。

现第一维由 $i$ 转移向 $i +1$，我们考虑 $i +1$ 是否加入删点集合，如果不加入，那么进行转移 $f_{i+1, 0, a} \gets f_{i, a, b}$，否则转移就有些麻烦。

根据上文的结论，简单环一定会走恰好两条 $2$ 类边，那么我们不妨讨论这类边在两条路径上的存在情况：

1. 若 $path_i$ 和 $path_{i - 1}$ 均不存在 $2$ 类边，那么 $to_{i +1}$ 可以考虑根据 $i - 1$ 是否存在于删点集合中来继承 $to_{i - 1}$，而 $to_{i}$ 可以考虑根据 $path_i$ 中是否能够加入一条以 $i+1$ 为终点的 $2$ 类边来继承 $to_{i+1}$。

2. 若 $path_i$ 不存在 $2$ 类边而 $path_{i- 1}$ 存在，可以发现如果 $to_{i} +k \le i +1$ 或者 $to_{i - 1} +k = i +1$ 都会出现环的情况，此时我们不予转移，否则我们令 $to_{i +1}$ 继承 $to_{i - 1}$，令 $to_i$ 继承自己即可。

3. 若 $path_i$ 存在 $2$ 类边而 $path_{i- 1}$ 不存在，那么我们直接考虑 $to_{i +1}$ 是否能够继承 $to_{i - 1}$ 即可，此时 $to_i$ 不会受到任何影响，也不会出现环的情况。

4. 若 $path_i$ 和 $path_{i- 1}$ 均存在 $2$ 类边，这种情况和第 $2$ 种情况几乎一样，不过此时 $to_{i} +k \le i + 1$ 一定不会成立，因此我们仅需判断 $to_{i - 1} +k = i +1$ 是否成立即可。

[代码实现](https://atcoder.jp/contests/agc035/submissions/37810036)

{% endnote %}

------

- [AGC035D Add and Remove](https://atcoder.jp/contests/agc035/tasks/agc035_d)

题解：

{% note success flat %}

对于这种题，一般考虑计算每个元素对答案的贡献系数。

把删除的过程倒过来，假设我们在 $a_i$ 和 $a_{i +1}$ 之间加入了一个数，并且 $a_i$ 和 $a_{i +1}$ 的贡献系数分别为 $c_i$ 和 $c_{i +1}$，那么新加入的数的贡献系数即为 $c_i +c_{i+1}$。

设 $f_{l, r, u, v}$ 表示对于区间 $[l, r]$，$a_l$ 和 $a_r$ 的贡献系数分别为 $u$ 和 $v$，整个区间除 $a_l$ 和 $a_r$ 外的最小贡献和，转移考虑枚举断点，并将其作为整个区间除 $a_l$ 和 $a_r$ 外最后一个被删除的数即可。最后的答案即为 $f_{1, n, 1, 1} + a_1 +a_n$。

由于 $(u, v)$ 会呈满二叉树的形态扩展，因此状态数的上界为 $\mathcal{O}(n^2\cdot 2^n)$，完全可以通过此题。不过据兔队的精密计算，状态数实际上是 $\mathcal{O}(2^n)$ 的。

[代码实现](https://atcoder.jp/contests/agc035/submissions/37819895)

{% endnote %}

------

- [AGC034F RNG and XOR](https://atcoder.jp/contests/agc034/tasks/agc034_f)

题解：

{% note success flat %}

设 $f_i$ 表示 $x$ 第一次变成 $i$ 的期望次数，那么可以得到如下 $2^n$ 个方程：
$$
\begin{aligned}
f_0 &= 0
\\
f_i &= 1 + \sum_{j~\texttt{xor}~k = i} f_j \cdot a_k~(i \ne 0)
\end{aligned}
$$
我们不妨将其写成生成函数的形式：$F(x) = I(x) + F(x) \cdot A(x)$，其中 $\forall i \in [0, 2^n), [x^i]I(x) = 1$。

但是，考虑到 $\displaystyle \sum_{i = 0}^{2^n - 1} a_i = 1$，因此左侧还需要加上常数 $2^n$，即 $F(x) + 2^n = I(x) +F(x) \cdot A(x)$，那么就有 $\displaystyle F(x) = \frac{I(x) - 2^n}{1 - A(x)}$，这个用 $\mathcal{FWT}$ 做一做即可。
不过，最后得出的 $F(x)$ 可能会有 $[x^0]F(x) \ne 0$，不过我们回到原方程可以发现，给每一个数都加上一个固定的常数 $c$  不会有任何影响，我们根据这个来进行微调即可。

[代码实现](https://atcoder.jp/contests/agc034/submissions/37846513)

{% endnote %}

------

- [AGC030E Less than 3](https://atcoder.jp/contests/agc030/tasks/agc030_e)

题解：

{% note success flat %}

考虑在所有 $0 \rightarrow 1$ 的分界处放一条红线，在所有 $1 \rightarrow 0$ 的分界处放一条蓝线，并且假设左右两端有无限条线，串中的所有线都满足红蓝交替的规律。

注意到翻转一个数时，这个数左右两侧的数必定不同，那么翻转数的操作我们实际上可以看做移动分界线。特别地，左右两侧可以无限地加入和减少分界线。

对于一个分界线的对应方案，答案的下界为每组对应分界线的位置差之和，而这个下界实际上是可达的，其原因是，由于连续段长度不超过 $2$，说明不可能存在相邻两条分界线，一条移动方向向左，一条移动方向向右，那么所有分界线都会被不需要移动的分界线分为若干组，每组的移动方向相同，显然一定存在一组合法的方案，满足答案达到这个下界。

那么，我们仅需考虑求出一种将所有分界线一一对应的方案，使得答案最小即可，而这样的方案最多仅有 $\mathcal{O}(n)$ 种，因为左侧至多会加入或减少 $\mathcal{O}(n)$ 条分界线，而每一种加入或减少分界线的数量都会唯一对应一种方案。这样的话，我们枚举每一种方案计算答案即可，总的复杂度是 $\mathcal{O}(n^2)$ 的。

[代码实现](https://atcoder.jp/contests/agc030/submissions/37855892)

{% endnote %}

------

### Day 3 2023.1.7 - 2023.1.8 图论与网络流

#### 笔记

- 对于一个二分图，我们可以用如下算法构造其最小点覆盖方案：从左部点中的非匹配点开始，尝试寻找一条增广路，将经过的节点打上标记，最终最小点覆盖的方案为左部点中未被标记的节点和右部点中被标记的节点。

- 在 $\mathcal{Floyd}$ 算法中，三层循环的正确的枚举顺序应该是 $k \to i \to j$，但实际上若我们确定一个枚举顺序 $\alpha$，按照 $\alpha$ 跑三遍 $\mathcal{Floyd}$，得出的结果也是正确的。

- 要将一个无向图的所有边定向，并形成一个 $\mathcal{SCC}$，存在方案的充要条件是图中不存在割边。如果图中不存在割边，那么我们考虑任意找出一颗 $\mathcal{DFS}$ 树，将所有树边由父亲连向儿子，所有非树边由子孙连向祖先，可以证明这样连出来的有向图一定是一个 $\mathcal{SCC}$。

- 对于一张连通的、带权的无向图，我们有办法判断点 $u$ 和点 $v$ 之间是否存在一条权值为 $w$ 的路径（不一定是简单路径）的边权异或和：首先 $\mathcal{DFS}$ 一遍整棵树，找出所有由若干树边和一条返祖边组成的简单环并将它们的边权异或和加入线性基，此时线性基张成了图中所有的环。然后任意找出一条点 $u$ 和点 $v$ 之间的路径，设其边权异或和为 $l$，那么我们仅需判断 $l\space\texttt{xor}\space w$ 是否存在于线性基中即可。

------

#### 题目

- [AGC056C 01 Balanced](https://atcoder.jp/contests/agc056/tasks/agc056_c)

题解：

{% note success flat %}

考虑把 $0$ 赋权为 $1$，把 $1$ 赋权为 $-1$，设权值的前缀和为 $sum_{0 \sim n}$，那么为了满足答案字典序最小的条件，我们需要让 $sum_i$ 的字典序最大。

$sum_i$ 的限制有哪些呢？首先有 $\forall i \in [1, n], |sum_i - sum_{i - 1}| = 1$，我们不妨将其改写为 $\forall i \in [1, n], |sum_i - sum_{i - 1}| \le 1$，下文将会证明实际上并不存在 $sum_i = sum_{i - 1}$ 的情况。其次，它还存在若干来自子串的限制，而子串 $[l, r]$ 合法等价于 $sum_r = sum_{l - 1}$。

可以发现这两条限制都能改写为双向的不等式的形式，那么我们对其建立差分约束系统并求解最短路即可，而差分约束系统的性质又恰好能够使解满足 $sum_i$ 字典序最大的条件。注意到这样连边后，$sum_i$ 与 $sum_{i - 1}$ 的奇偶性必然是不同的，因此 $sum_i = sum_{i - 1}$ 这种情况是不会出现的。

到了这一步，我们可以考虑直接用堆优化 $\mathcal{Dijkstra}$ 求解。不过，注意到所有的边均为双向边，并且边权只有 $0$ 和 $1$，那么我们也可以用 $0/1\space\mathcal{BFS}$ 求解。

[代码实现](https://atcoder.jp/contests/agc056/submissions/37895004)

{% endnote %}

------

- [CF160D Edges in MST](https://www.luogu.com.cn/problem/CF160D)

题解：

{% note success flat %}

考虑把边权相同的边分为一类，然后按照边权从小到大处理。

对于当前枚举到的边权 $w$，考虑其中的一条边 $(u, v)$，若 $u$ 和 $v$ 已经通过若干条边权小于 $w$ 的边连通，那么该边显然不可能在任何一颗 $\mathcal{MST}$ 中。否则，我们考虑所有边权不超过 $w$ 的边形成的一张图 $\alpha$，若一条边 $(u, v)$ 在所有的 $\mathcal{MST}$ 中，那么在图 $\alpha$ 中它必然不能位于任意一个环中，否则它必然位于某些环中。也就是说，边 $(u, v)$ 在所有 $\mathcal{MST}$ 的充要条件是：它在图 $\alpha$ 中是一条割边。这样，我们每次加入一类边时，就用 $\mathcal{Tarjan}$ 求出其中的割边和非割边，然后在将图 $\alpha$ 中的连通块通过并查集缩点即可。

[代码实现](https://codeforces.com/contest/160/submission/188562925)

{% endnote %}

------


## 模拟赛总结

### Test No.1 2023.1.2

#### 总结

{% note success flat %}

开考时先看完了三个题的题面，发现都不是我擅长的题型，于是就按照顺序进行开题。很快发现了 T1 的一个结论，然后想到了 30 pts 的做法，细想了一会发现自己不会别的做法了，于是就开写。由于细节比较多，到 10 点左右才差不多写完调完。这个时候再细想了一下，感觉还是不会 T1 更高得分的做法，于是就开了后面的题目。T2 很快写了一个 30 pts 的暴力，然后想试试写一档 15 pts 的部分分，但是没有触碰到网络流这个关键点，所以最后没有多写任何别的做法，跳到了下一题。T3 很快写了一个 AC 自动机，调了一会就发现题目看错了，这个时候离下考只有 20 min，想了想感觉不会正确的暴力做法，所以就放弃了这道题。最后重新审视了一遍所有题目，尤其是 T1，仔细思考了自己做法的一个部分之后突然想到了正解，然而此时离下考只有 10 min 了，并且计算几何由于过久没有碰也不是很熟练，所以最后没有选择冲正解，整场考试的分数定格在了 60 pts。最后稍微检查了下程序，就下考了。

最后 60 pts 没有挂分，并且意料之外地获得了 rk 2，所以以后的考试无论多难都要调整好心态，做好自己就是最好的发挥。T1 正解想到得较晚，T2 根本没有想到网络流，T3 字符串不熟练导致没有拿到分数，三者均因为知识点的不熟练导致各种失误，因此日后要好好将缺失的技能树补齐。T3 还有一次看错题的经历，所以下次做题之前不仅要读懂题面，还要模拟样例或是写一个及其暴力的程序来验证自己是否读对了题。

{% endnote %}

------

#### 题目

- T1 计算几何科技

题解：

{% note success flat %}

首先特判斜率为 $0$ 和斜率为 $+\infty$ 的情况，然后剩下的情况都可以转化为斜率为正的情况。

对于一条斜率为正的直线，它一定能够将所有矩形左上角和右下角的顶点分离。那么，我们可以考虑对二者分别求出凸包，若两个凸包严格相交则说明无解，反之则说明有解。

如何判断两个凸包是否严格相交呢？设两个凸包分别为 $\text{A}$ 和 $\text{B}$，我们将 $\text{B}$ 取反，然后求出二者的闵可夫斯基和 $\text{C}$，再判断 $(0, 0)$ 是否严格在 $\text{C}$ 内即可。当然，我们判断其中一个凸包是否存在一个顶点严格在另一个凸包内也是可以的。

{% endnote %}

------

- T2 图论科技

题解：

{% note success flat %}

首先套路性地将曼哈顿距离转化为切比雪夫距离。

将绝对值拆开，那么设黑点 $i$ 的坐标为 $(x_i, y_i)$，白点 $j$ 的的坐标为 $(x_j', y_j')$，则二者匹配的贡献为： $\max(x_i - x_j', x_j' - x_i, y_i - y_j', y_j' - y_i)$。

这个 $\max$ 式由四个部分构成，我们不妨设四种颜色来表示它们，那么对于其中的一个部分，我们就能够看做是黑白两点和该颜色形成了一组带权的匹配。

匹配这个关键词可以让我们想到网络流，那么对该题建立一个简单的费用流模型即可得出正确答案，但是复杂度无法接受。

不过，既然我们已经有了费用流模型，那么不妨考虑模拟费用流。

可以发现一条流一定是类似这种形式的：源点 $\to$ 左侧点 $\to$ 中间点 $\to$ 右侧点 $\to$ 中间点 $\to$  左侧点 $\to \cdots \to$ 汇点。我们可以将其分为三个部分：从原点到中间点的路径、从中间点到汇点的路径、以及在左侧点、右侧点和中间点三者之间徘徊的路径。那么我们仅需用 $\texttt{set}$ 时刻维护三者的最优解即可模拟费用流。

{% endnote %}

------

### 省选 10 连测 No.2 2023.1.8

#### 总结

{% note success flat %}

开考时阅读了三道题的题面，感觉 T1 没有什么思路，T2 一眼秒了（后来发现是看错题了），T3 可以玩一玩，于是就决定开题顺序为 T2 - T3 - T1。T2 对着看错的题面调了好久的代码，大概到 10 点左右发现题目看错了，还得重新开始思考，不一会就发现了答案可以表示为一个很简洁的式子，先想到了用莫队做，然后发现时间复杂度不对（但不知道在随机数据下是正确的），接着陆续想到了几个假的根号分治做法，最后仍然没有得出一个比较优秀的算法，于是写了 20 分就跳过了这题。这时心态已经十分爆炸了，于是就有点摆烂，没有想着去拿满部分分，而是想去玩一玩 T3，最终的结果是只拿到了 12 分，还漏掉了两档可以拿到的部分分。最后看到 T1 时仅剩下 10 min 了，阅读了一下题目之后感觉部分分其实很好拿，并且不一会就想到了这题是网络流题，于是有些后悔没有早点开 T1，但接着就下考了，后悔也无济于事了。

这次考试主要就是栽在 T2 上，而这种问题我已经不是第一次出现了，T1 和 T3 都有可以在短时间内拿到的部分分，可我由于心态爆炸几乎没有去写。所以，考试的心态还是要平稳，不能太过高昂 —— 想出了做法要再三确认其正确性以及读题的正确性，不要由于太过激动而去无脑冲一个没有正确性保证的做法；也不能太过低沉 —— 即使是出现了重大失误也应该即使止损，而不是任其发展，把翻盘的希望扼杀在摇篮中。自己在心态方面一直都做得不够好，日后还需要多多改善。

{% endnote %}

------

#### 题目

- [T1 修建城墙](http://zhengruioi.com/problem/2494)

题解：

{% note success flat %}

对于 $\text{L}$ 的情况，我们考虑若两面不存在的城墙相交且垂直，那么两面城墙应至少修建一面。我们可以对此建立一个二分图模型，那么该二分图的最小点覆盖即为答案，我们用网络流求解即可，最终的方案即为最小点覆盖的方案。

对于 $\text{T}$ 的情况，每个方格在四个方向上未修建城墙的面数应不超过 $2$。我们不妨设格点 $a_{i, j}$ 表示格点 $(i, j)$ 还应修建多少面城墙才合法，假设我们构造一种方案满足所有的 $a_{i, j}$，那么必然会出现重复计算的边，我们不妨考虑求解重边的最大数量 $cnt$，这样我们就能够得到答案了。求解 $cnt$ 相当于求一个城墙的集和，满足对于所有格点 $(i, j)$，四个方向上的城墙都有不超过 $a_{i, j}$ 面在这个集合中，由于网格图是二分图，因此我们仍然可以用网络流求解。至于最终的方案，首先 $cnt$ 所对应的边集要加入其中，然后我们再重新计算一遍每个格点的 $a_{i, j}$，并在每个格点的左方或上方（为了不修建重复的城墙）修建城墙以满足 $a_{i, j}$ 的要求即可。

[代码实现](http://zhengruioi.com/submission/587762)

{% endnote %}

------

## 未完待续 ……