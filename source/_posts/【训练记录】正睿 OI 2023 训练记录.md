---
title: 【训练记录】正睿 OI 2023 训练记录

date: 2023-01-03 16:46:29

description: 本文为正睿 OI 2023 的训练记录。

non-public: true

katex: true

tags:

- 训练记录
 
categories: 

- OI

- 正睿 OI

sticky: 1

cover: /img/13.png
---

## 听课记录

### Day 1 2022.12.31 数据结构

暂时咕了。

------

### Day 2 2023.1.1 计数

#### 笔记

- 对于一个 $n$ 个节点的树，设以点 $u$ 为根的子树大小为 $si_u$，现给节点 $u$ 赋以权值 $p_u$，满足 $p_{1 \sim n}$ 构成 $1\sim n$ 的一个排列，且对于每条边而言，父亲节点的权值小于儿子节点的权值，这样的赋权方案数为 $\displaystyle n! \prod_{i = 1}^n\frac{1}{si_u}$。
- 对于一个 $1 \sim n$ 的排列 $p_{1 \sim n}$，现限制 $\forall i \in[1, n], p_i \in[1, r_i]$，这样的排列数为 $\displaystyle \prod_{i = 1}^n (r_i' - i + 1)$，其中 $r_i'$ 表示将 $r_i$ 从小到大排序后形成的新序列。

------

#### 题目

##### [AGC060C Large Heap](https://atcoder.jp/contests/agc060/tasks/agc060_c)

题解：

考虑将左右两条链归并，把原来在左边的点称为 $1$ 类点，原来在右边的点称为 $2$ 类点。

那么根据归并后链的尾部是 $1$ 类点还是 $2$ 类点，我们就可以知道 $p_u$ 和 $p_v$ 的大小关系。

考虑设 $f_{i, j}$ 表示左侧归并了 $i$ 个点，右侧归并了 $j$ 个点的方案数，转移方程显然。

转移的最后，我们考虑统计最后归并的是 $1$ 类点的方案数 $val_1$ 和是 $2$ 类点的方案数 $val_2$，那么答案即为 $\displaystyle \frac{val_2}{val_1 +val_2}$。

代码实现：

暂时咕了。

------

##### [AGC060D Same Descent Set](https://atcoder.jp/contests/agc060/tasks/agc060_d)

题解：

考虑枚举大于号的位置集合 $S$，设 $f_S$ 表示其方案数，那么答案即为 $\displaystyle \sum_S f_S^2$。

对于这种问题，直接做必然是很困难的，我们考虑容斥，设 $g_S$ 表示大于号集合是 $S$ 的超集的方案数，那么答案为 $\displaystyle \sum_S(\sum_{S \subseteq T} (-1)^{|T|-|S|} \cdot g_T)^2$。

把后面的平方式拆开，改变一下枚举顺序就有 $\displaystyle \sum_{T_1, T_2} (-1)^{|T_1| + |T_2|} \cdot g_{T_1}\cdot g_{T_2} \cdot 2^{|T_1\cap T_2|}$。

我们发现 $2^{|T_1\cap T_2|}$ 比较难搞，不妨把它拆开，变成 $2^{|T_1|+|T_2| - (n - 1) + |\overline{T_1} \cap \overline{T_2} |}$，那么原式可以化为 $\displaystyle \frac{1}{2^{n - 1}}\sum_{T_1, T_2} ((-2)^{|T_1|} \cdot g_{T_1})\cdot ((-2)^{|T_2|} \cdot g_{T_2}) \cdot 2^{|\overline{T_1}\cap \overline{T_2}|}$。

接下来我们考察 $\overline{T_1}\cap \overline{T_2}$ 的意义：它表示两个集合均为 $0$ 的位置，也就是均未被钦定为大于号的位置。注意到这些位置把整个序列分为了若干段，每一段都不存在两个集合均为 $0$ 的位置，那么 $2^{|\overline{T_1}\cap \overline{T_2}|}$ 这个部分可以贡献到每一段上，最后再乘上一个 $\displaystyle \frac{1}{2}$ 的系数，我们不妨将这个系数提到外面。

我们设一段的方案数的 $\mathcal{OGF}$ 为 $G(x)$（注意其常数项为 $0$），设总的方案数的 $\mathcal{OGF}$ 为 $F(x)$，这样原式就变为了 $\displaystyle \frac{1}{2^{n}} \cdot [x^n]F(x)$。

通过二者的关系，我们可以得出 $\displaystyle F(x) = \frac{1}{1 - 2\cdot G(x)}$。那么，只要我们求出求出了 $G(x)$，就可以通过多项式求逆求出 $F(x)$，进而求出答案。

接下来我们考察 $g_S$ 的意义。

注意到连续的一段大于号会确定对应的连续的一段位置的大小关系，因此 $g_S$ 可以表示为 $\displaystyle \frac{n!}{\displaystyle \prod_{i = 1}^m l_i!}$ 的形式，我们不妨将 $n!$ 这个系数提到外面去。

至于前面的系数 $(-2)^{|T_1|}$，我们考虑设段的长度为 $m$，那么原式中的 $(-2)^{|T_1|} \cdot g_{T_1}$ 就可以转化为 $\displaystyle \frac{(-2)^m}{\displaystyle \prod_{i = 1}^{m - |T_1|} (-2 \cdot l_i!)}$。

现在我们设 $H(x)$ 表示一段的方案数的 $\mathcal{OGF}$（注意其常数项也为 $0$），但没有 “不存在两个集合均为 $0$ 的位置” 这个限制。

根据上文 $g_S$ 的意义，设 $\displaystyle I(x) =\frac{1}{\displaystyle 1 + \frac{1}{2} \cdot (e^x - 1)}$，那么其第 $m$ 项的系数为 $\displaystyle ((-2)^m \cdot [x^m]I(x))^2$。

最后，我们可以得出，$G(x)$ 和 $H(x)$ 存在关系 $H(x) = G(x) \cdot (H(x) +1)$，转化一下式子可得 $\displaystyle G(x) = \frac{H(x)}{H(x)+1}$，这样我们就可以得出答案了。

代码实现：

暂时咕了。

------

##### [AGC059C Guessing Permutation for as Long as Possible](https://atcoder.jp/contests/agc059/tasks/agc059_c)

题解：

对于三个下标 $i, j, k$ 而言，若最后一组询问为 $(i, k)$，说明 $p_j$ 是 $p_i, p_j, p_k$ 三者中的极值。

此时会存在两组等价关系：$p_i < p_j \Leftrightarrow p_j >p_k$ 和 $p_i >p_j \Leftrightarrow p_j < p_k$。那么我们可以对形如 $p_i < p_j$ 的关系建图，然后通过上述结论连边。

可以发现，这样连出来的图是对称的，每个连通块都会与另外一个连通块唯一对应。

对于一个连通块而言，我们仅需知道其中一组关系的真假性，就可以知道它和它对应的另一个连通块内所有关系的真假性。

确定了 $\displaystyle \frac{n \cdot (n - 1)}{2}$ 组关系之后，我们就能够唯一确定这个排列了。所以，设连通块个数为 $m$，则答案为 $2^{\frac{m}{2}}$。

代码实现：

[$\mathcal{Link~to~AtCoder}$](https://atcoder.jp/contests/agc059/submissions/37699598)

------

##### [AGC054C Roughly Sorted](https://atcoder.jp/contests/agc054/tasks/agc054_c)

题解：

对于一个不合法的排列而言，要使得操作次数最小，就要保证每次操作都会减小一组逆序对。

那么，我们可以考虑从给定的排列出发，进行若干次操作，满足每次操作过后，排列都是不合法的，且都会增加一组逆序对。

设 $cnt_i = \displaystyle \sum_{j = 1}^{i - 1} [p_j >p_i]$，那么要满足第一个要求，我们就必须移动 $cnt_i$ 恰好为 $k$ 的位置 $i$，要满足第二个要求，我们就必须移动满足 $p_i >p_{i +1}$ 的位置 $i$ 。

注意到对于满足第一个要求的 $i$，它的后面一定不存在比它小的位置，否则这个比它小的位置的 $cnt_i$ 一定会大于 $k$。

那么，每个满足第一个要求的 $i$ 都可以向后移动最多 $n - i$ 次，并且这些位置的每一种移动次数的组合都会对应唯一的最初排列。

综上所属，设合法的位置为 $q_{1 \sim m}$，那么答案即为 $\displaystyle \prod_{i = 1}^m (n - q_i + 1)$。注意可能不存在合法的位置，此时答案为 $1$。

代码实现：

[$\mathcal{Link~to~AtCoder}$](https://atcoder.jp/contests/agc054/submissions/37693812)

------

##### [AGC043D Merge Triplets](https://atcoder.jp/contests/agc043/tasks/agc043_d)

题解：

考虑对于一个位置 $i$ 而言，若 $p_i >p_{i +1}$，说明 $p_i$ 和 $p_{i +1}$ 必然在同一个段内。

也就是说，合法的排列不会存在长度超过 $3$ 的单调下降的子段。我们得出了一个必要条件。

那么，我们可以考虑通过前缀 $\max$ 的值将合法的排列分为若干块，每一块的长度都不超过 $3$。

现在我们需要将这些段组合为 $n$ 个长度为 $3$ 的段，那么长度为 $3$ 的块可以自成一段，长度为 $2$ 的块只能和长度为 $1$ 的块组合为一段，长度为 $1$ 的块可以和另外两个长度为 $1$ 的块组合为一段。这样，我们得出了一个充分条件 —— 长度为 $1$ 的块的数量一定不能少于长度为 $2$ 的块的数量。

接下来我们考虑讨论一下这些块对答案的贡献。由于每个块的第一个位置必然是前缀的最大值，因此，若所有块的右端点分别为 $q_{1\sim m}$，则总的方案数为 $\displaystyle \frac{n!}{\displaystyle \prod_{i = 1}^m q_i}$。

到了这里，我们就可以考虑 $\mathcal{DP}$ 了—— 设 $f_{i, j}$ 表示考虑 $1 \sim i$ 这些数，长度为 $1$ 的块的数量减去长度为 $2$ 的块的数量等于 $j$ 的方案数，转移考虑在排列尾部增添一个长度不超过 $3$ 的块，然后乘上相应的贡献系数即可。

代码实现：

[$\mathcal{Link~to~AtCoder}$](https://atcoder.jp/contests/agc043/submissions/37704274)

------

##### [AGC039E Pairing Points](https://atcoder.jp/contests/agc039/tasks/agc039_e)

题解：

下设 $n$ 为题目中的 $N \cdot 2$。

考虑与点 $1$ 相连的点，设其为点 $i$，那么为了使连出来的图形成一棵树，在 $[2, n]$ 这个区间内，我们需要在 $[2, i)$ 内从左往右选出若干个点 $p_{1 \sim m}$，，在 $(i, n]$ 内从右往左选出若干个点 $q_{1 \sim m}$，使得对于所有 $j \in [1, m]$，点 $p_j$ 与点 $q_j$ 相连，然后再将剩下的点在两个区间内部相连。

这样，不妨设 $f_{l, r, i}$ 表示在区间 $[l, r]$ 内连边，其中只有点 $i$ 向区间外连边的方案数。最终的答案即为 $\displaystyle \sum_{i = 3}^{n - 1}f_{2, n, i}$。

考虑转移，我们枚举分居 $i$ 的两侧的两点 $j, k$，令它们之间连一条边。对于区间 $(j, i)$，可以发现必然存在一个分界点 $p$，满足 $(j, p]$ 内的点的连边会与 $j$ 的连边相交，$(p, i)$ 内的点的连边会与 $i$ 的连边相交，区间 $(i, k)$ 同理存在一个分界点 $q$。

根据上述分析，我们有转移：
$$
f_{l, r, i} = \sum_{j = l + 1}^{i - 1}\sum_{k = i +1}^{r - 1}[a_{j, k} = 1]\sum_{p = j+1}^{i - 1}\sum_{q = i+1}^{k- 1}f_{l, p, j} \cdot f_{p+1, q - 1, i} \cdot f_{q, r, k }
$$
边界条件为对于所有 $i \in [2, n]$，$f_{i, i, i} = 1$。

这样我们就得到了一个 $\mathcal{O}(n^7)$ 的做法，不过带了一个十分小的常数。

考虑优化。我们不妨交换枚举顺序：
$$
f_{l, r, i} = \sum_{p = l +2}^{i - 1}\sum_{q = i+ 1}^{r - 2} f_{p+1, q - 1, i} \sum_{j = l +1}^{p - 1}\sum_{k = q + 1}^{r - 1}[a_{j, k} = 1] \cdot f_{l, p, j} \cdot f_{q, r, k }
$$
可以发现枚举了 $p, q$ 后，后面的一部分都和 $i$ 没有关系了，那么我们不妨先枚举 $l, r$，再枚举 $p, q$，把后面这一部分算出来之后再枚举 $i$。

如何求后面这一部分呢？我们设 $\displaystyle g_{l, p, k} = \sum_{j = l+ 1}^{p - 1}[a_{j, k}=1]\cdot f_{l, p, j}$，那么这一个部分就等于 $\displaystyle\sum_{k = q +1}^{r - 1}g_{l, p, k} \cdot f_{q, r, k}$，我们在枚举了 $p, q$ 之后再计算即可。

这样时间复杂度就降至了 $\mathcal{O}(n^5)$。

代码实现：

暂时咕了。

------

##### [AGC036F Square Constraints](https://atcoder.jp/contests/agc036/tasks/agc036_f)

题解：

对于 $[0, n)$ 内的所有位置 $i$，它们具有限制 $p_i \in [l_i, r_i]$，而对于 $[n, n\cdot 2)$ 内的所有位置 $i$，它们具有限制 $p_i \in [0, r_i]$，其中涉及到的所有 $l_i, r_i$ 均为正整数。

考虑容斥 $[0, n)$ 内的所有位置，设容斥集合 $S$，那么 $S$ 内的所有位置 $i$ 的限制为 $p_i \in [0, l_i)$，$S$ 外的所有位置 $i$ 的限制为 $p_i \in [0, r_i]$，我们统一记为 $a_i$。

我们可以考虑按照限制从小到大做 $\mathcal{DP}$，设 $f_{i, j}$ 表示枚举了前 $i$ 个限制，其中有 $j$ 个位置在 $S$ 内。

转移时，对于 $[n, n\cdot 2)$ 内的所有位置，由于它们不会被容斥，因此它们的贡献是好算的，而对于 $[0, n)$ 内的所有位置，若它们在 $S$ 内，它们的贡献也可以通过 $j$ 算出，但如果它们不在 $j$ 内，我们就必须引入 $|S|$ 这个量才能算出它的贡献。

这样的话，我们可以考虑在外层枚举 $|S|$，内层做这个 $\mathcal{O}(n^2)$ 的 $\mathcal{DP}$，然后将 $(-1)^{|S|} \cdot f_{n\cdot2, |S|}$ 这个贡献加入答案中，总的时间复杂度为 $\mathcal{O}(n^3)$。

代码实现：

暂时咕了。

------

##### [AGC035E Develop](https://atcoder.jp/contests/agc035/tasks/agc035_e)

题解：

对于一种合法的删数方案，若同时存在 $x$ 和 $x - 2$，则 $x$ 必然会先删，否则 $x - 2$ 被删之后，$x$ 被删又会导致其重新被加入集合中，$x$ 和 $x + k$ 是同理的。

考虑对 $1\sim n$ 这些数建有向图，对于每个 $x$，连边 $x\rightarrow x - 2$ 和 $x \rightarrow x + k$（下文分别称为 $1$ 类边和 $2$ 类边），表示删边顺序，那么对于一个删数集合，若不存在环，我们就可以按照拓扑序删数，这说明合法的充要条件是删数集合所对应的导出子图不存在环。

若 $k$ 为偶数，可以发现奇数和偶数两个部分是独立的，这里我们仅考虑奇数的情况，可以发现奇数的图中仅会存在形如 $x \rightarrow x-2 \rightarrow \cdots \rightarrow x - k \rightarrow x$，那么唯一的限制就是不能删除连续的 $\displaystyle \frac{k}{2} +1$ 个奇数，我们随便 $\mathcal{DP}$ 一下即可。

若 $k$ 为奇数，可以发现如果存在环，那么环一定能够拆成若干简单环，而简单环一定会走恰好两条横跨奇数和偶数两个部分的边，也即 $2$ 类边，那么我们仅需限制图中不存在简单环即可。

考虑对于点 $x$，如果它能够成简单环，那么一定是一个形如 $x \rightarrow x - 2 \rightarrow \cdots y - k \rightarrow y \rightarrow y - 2 \cdots \rightarrow x - k \rightarrow x$ 的环，即先不断走 $1$ 类边，再走一条 $2$ 类边，再不断走 $1$ 类边，最后走回点 $x$。

我们不妨考虑维护这样的一条路径，它要求尽可能地在被删点的集合中走一条 $2$ 类边，并且在满足前者的情况下尽可能地向左侧延伸，这样是为了及时判断成环的情况。记以点 $x$ 作为起点的这条路径为 $path_x$，其最远能够到达 $to_x$，我们可以考虑将后者放入 $\mathcal{DP}$ 状态中，这样遇到会成环的情况我们就能够及时规避。

设 $f_{i, a, b}$ 表示考虑点 $1 \sim i$，且满足 $to_i = a, to_{i - 1} = b$ 的删点集合的方案数，记录 $b$ 这一维是为了方便转移。

现第一维由 $i$ 转移向 $i +1$，我们考虑 $i +1$ 是否加入删点集合，如果不加入，那么进行转移 $f_{i+1, 0, a} \gets f_{i, a, b}$，否则转移就有些麻烦。

根据上文的结论，简单环一定会走恰好两条 $2$ 类边，那么我们不妨讨论这类边在两条路径上的存在情况：

1. 若 $path_i$ 和 $path_{i - 1}$ 均不存在 $2$ 类边，那么 $to_{i +1}$ 可以考虑根据 $i - 1$ 是否存在于删点集合中来继承 $to_{i - 1}$，而 $to_{i}$ 可以考虑根据 $path_i$ 中是否能够加入一条以 $i+1$ 为终点的 $2$ 类边来继承 $to_{i+1}$。

2. 若 $path_i$ 不存在 $2$ 类边而 $path_{i- 1}$ 存在，可以发现如果 $to_{i} +k \le i +1$ 或者 $to_{i - 1} +k = i +1$ 都会出现环的情况，此时我们不予转移，否则我们令 $to_{i +1}$ 继承 $to_{i - 1}$，令 $to_i$ 继承自己即可。

3. 若 $path_i$ 存在 $2$ 类边而 $path_{i- 1}$ 不存在，那么我们直接考虑 $to_{i +1}$ 是否能够继承 $to_{i - 1}$ 即可，此时 $to_i$ 不会受到任何影响，也不会出现环的情况。

4. 若 $path_i$ 和 $path_{i- 1}$ 均存在 $2$ 类边，这种情况和第 $2$ 种情况几乎一样，不过此时 $to_{i} +k \le i + 1$ 一定不会成立，因此我们仅需判断 $to_{i - 1} +k = i +1$ 是否成立即可。

代码实现：

暂时咕了。

------

## 模拟赛总结

近期暂时没有模拟赛。