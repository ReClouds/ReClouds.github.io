---
title: 【学习笔记】我们仍未理解那天所学习的数论算法

date: 2023-01-30 09:01:05

description: 本文将会讲解部分数论的知识点和算法。

katex: true

tags:

- 学习笔记
 
categories: 

- OI

- 数学

- 数论

sticky: 2

cover: /img/14.jpg

---

## 前言

对于部分基础的数论知识点（如整除、同余等），笔者不会再进行讲解。因此，笔者希望有扎实的数论基础的读者来阅读这篇文章。

------

## 中国剩余定理

对于线性同余方程组 $x \equiv a_i \pmod{p_i}$，中国剩余定理能够求解其最小非负整数解。

这个算法要分为两种情况讨论，而两种情况的算法实际上存在本质区别。

------

### 模数两两互质

我们有如下基于构造思想的算法：

设 $\displaystyle \text{M} = \prod_{i = 1}^mp_i$，$\text{M}_i = \dfrac{\text{M}}{p_i}$，$\text{M}_i^{-1}$ 为 $\text{M}_i$ 在模 $p_i$ 意义下的逆元，那么整个方程组的最小非负整数解为 $\displaystyle (\sum_{i = 1}^m a_i\cdot \text{M}_i\cdot \text{M}_i^{-1}) \bmod \text{M}$。

证明：

{% note success flat %}

考虑这个和式的第 $i$ 项 $a_i \cdot \text{M}_i \cdot \text{M}_i^{-1}$，将其对 $p_i$ 取模即得到第 $i$ 个同余方程的特解 $a_i$，而将其对其它的 $p_j~(j \ne i)$ 取模均得到 $0$，所以这个项既能够满足第 $i$ 个同余方程，又不会对其它的同余方程造成影响。

这样，我们证明了这个和式是原方程的一个特解。

又因为方程组在 $[0, \text{M})$ 内仅存在一个解，因此将这个和式对 $\text{M}$ 取模即得到最小非负整数解。

{% endnote %}

值得一提的是，我们熟知的拉格朗日差值实际上是基于这一部分的算法的。

------

### 模数不两两互质

我们是否能够考虑套用上述算法的框架呢？

不行，因为 $\text{M}_i^{-1}$ 甚至有可能根本不存在。因此，仅对上述算法进行微调是不可行的。

我们考虑一个很简单的思想：合并同余方程。

对于前 $i$ 个同余方程，我们可以通过将它们合并得到一个形如 $x \equiv b_i \pmod{\text{M}_i}$ 的方程，这里的 $\text{M}_i$ 表示前 $i$ 个模数的 $\operatorname{lcm}$。

接下来我们考虑其和第 $i + 1$ 个方程的合并。

首先，我们将满足前 $i$ 个方程的 $x$ 写成 $b_i + \text{M}_i \cdot k~(k \in \Z)$ 的形式，那么我们仅需求出 $k$ 的一个特解便可得到前 $i + 1$ 个方程的特解。然后，我们将其带入第 $i + 1$ 个方程得到 $b_i +\text{M}_i \cdot k \equiv a_i \pmod{p_i}$，再将其转化为二元一次不定方程的形式，最后用 $\operatorname{exgcd}$ 求出 $k$ 的一个特解即可。在这个过程中，我们还可以判断方程组是否存在无解的情况。

------

实际上，若我们对于每一个方程，都将 $x$ 带上一个 $c_i$ 的系数，那么无论是上述的哪一种情况，对应的算法经过调整仍然是可行的。

读者不妨自行思考，在 $x$ 带上了系数的情况下，两种情况对应的算法分别应该如何调整。

------

## Miller-Rabin 质数判别算法

对于正整数 $n$，我们都知道存在时间复杂度为 $\mathcal{O}(\sqrt{n})$ 的判别其是否为质数的算法，但是对于较大的 $n$，这个算法的时间复杂度还是比较难以接受的。

是否有复杂度更优秀的算法呢？

------

### 费马测试

我们不妨考虑质数的性质，其中有一条名为费马小定理：若 $p$ 是质数，则对于所有 $x \in [1, p)$ 都有 $x^{p-1} \equiv 1 \pmod{p}$。

那么，我们是否可以通过随机一些 $x$，判断上述条件是否对于这些 $x$ 均成立，从而判断 $p$ 是否为质数呢？

很遗憾，不行，原因是存在[卡迈克尔数](https://baike.baidu.com/item/%E5%8D%A1%E8%BF%88%E5%85%8B%E5%B0%94%E6%95%B0/9083263)，对于这些数，我们无论如何都会将它们判别为质数。虽然它们的数量很少，但要预处理并特判它们也并不是简单的。

------

### 二次探测定理

我们不妨再来考虑质数的性质，其中有一条名为二次探测定理：若 $p$ 是质数，且有 $x^2 \equiv 1 \pmod{p}$，则 $x = 1$ 或 $x = p - 1$。

那么，我们是否可以通过将 $p - 1$ 分解为 $q \cdot 2^r$ 的形式，然后随机一些 $x$，依次判断是否有 $x^{q \cdot 2^{s + 1}} \equiv 1 \pmod{p}$ 且 $x^{q \cdot 2^s} \equiv 1~\texttt{or}~p -1 \pmod{p}$，最后再判断是否有 $x^{p -1}\equiv 1 \pmod{p}$，从而判断 $p$ 是否为质数呢？

很幸运，这是可以的，在 $x$ 随机的情况下，这个算法被证明有极高的正确率。事实上，参考[这里](https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test)和[这里](https://miller-rabin.appspot.com/)，我们可以通过调整测试数以得到确定性的判断结果，这样我们就无须担心算法的正确率，而仅需考虑一些需要特判的情况了。

------

最后，这个算法是可以做到单次测试 $\mathcal{O}(\log_2n)$ 的时间复杂度的，读者不妨自行思考如何实现。

需要代码实现的读者可以看[这里](https://www.luogu.com.cn/paste/lg590hy4)。

------

## Pollard-Rho 因数分解算法

对于正整数 $n$，我们还是都知道存在时间复杂度为 $\mathcal{O}(\sqrt{n})$ 和 $\mathcal{O}(n) - \mathcal{O}(\log_2n)$ 的对其进行质因数分解的算法，但是对于较大的 $n$，这些算法的时间复杂度还是比较难以接受的。

是有有复杂度更优秀的算法呢？

------

### 确定方向

同 $\mathcal{Miller-Rabin}$ 算法，我们可以考虑在非确定性算法上寻找出路：我们可以通过随机化算法找出 $n$ 的一个非平凡因子 $m$，即满足 $m \ne 1~\texttt{or}~n$ 且 $m \mid n$。这样，若找出 $p$ 的复杂度为 $\mathcal{O}(f(n))$，那么算法的总时间复杂度为 $\mathcal{O}(f(n)\log_2n)$。

直接随机显然是不行的，我们考虑一种更为优秀的随机化算法。

------

### 生日悖论

我们来思考这样一个问题：不考虑出生年份，并假设每年均为 $365$ 天，那么当一个房间内有至少多少人时，有两个人生日相同的概率能够达到 $50\%$？

直觉告诉我们答案应该为 $183$ 人，但如果我们列出不等式，便可以得到一个十分反直觉的正确答案：$23$ 人。这也就是为什么该数学事实被称为一个悖论。

注意到 $23$ 是一个 $365$ 的平方根级别的数。实际上，根据生日悖论，我们可以导出一个推论：若我们在 $[1, n]$ 的范围内随机生成一个数并将其加入序列中，那么当序列中第一次出现两个相等的数时，序列的长度是期望 $\mathcal{O}(\sqrt{n})$ 级别的。

这个推论将在下文起到非常重要的作用。

------

### 构造伪随机函数

我们考虑构造这样一个伪随机函数：$f(x) = (x^2 + c)\bmod n$，其中 $c$ 是随机的常数。

这个函数有什么性质呢？

我们随机一个初值 $s$，然后观察序列 $s, f(s), f(f(s)), \cdots$，可以发现，这个函数会从某个位置开始进入一个循环。如果将有向图模型建出，可以发现其和 $\rho$ 的形状相类似，这便是这个算法的名字的由来。

设上述序列为 $x_i$，再设序列 $y_i$，且有 $y_i = x_i \bmod m$（其中 $m$ 为 $n$ 的最小非平凡因子），可以发现 $y_{i +1} = (y_i^2 +c) \bmod m$ 仍然成立，也即 $y_i$ 的有向图模型同样和 $\rho$ 的形状相类似。

注意到若存在一对位置 $i, j$，满足 $x_i \not\equiv x_j \pmod{n}$ 和 $y_i \equiv y_j \pmod{m}$，则有 $n \nmid |x_i - x_j|$ 及 $m \mid |x_i - x_j|$，那么此时 $\gcd(n, |x_i - x_j|)$ 即为 $n$ 的一个非平凡因子。

而根据上文生日悖论的推论，$|i - j|$（也即 $y_i$ 的 $\rho$ 形图的环长） 期望是 $\mathcal{O}(\sqrt{m})\approx \mathcal{O}(n^{\frac{1}{4}})$ 级别的，那么，如果我们能够做到在 $\mathcal{O}(|i - j|)$ 的时间复杂度内找到 $n$ 的一个非平凡因子，我们就得到了一个复杂度十分优秀的算法。

------

### 算法流程

接下来我们考虑如何实现这个算法。

我们可以设置两个值 $u$ 和 $v$，分别从初值 $s$ 开始，每次令 $v$ 等于 $f(v)$，然后判断 $\gcd(n, |u - v|)$ 是否为一个非平凡因子。

然而这个算法存在两个问题：其一是 $u$ 可能不在 $y_i$ 的 $\rho$ 形图的环上，其二是有可能我们遍历了整个 $x_i$ 的 $\rho$ 形图的环都无法成功地找到一个非平凡因子。

这两个问题均可以用 $\mathcal{Floyd}$ 判环法来解决。具体地，我们还是设置两个值 $u$ 和 $v$，分别从初值 $s$ 开始，每次我们令 $u$ 等于 $f(u)$，令 $v$ 等于 $f(f(v))$。

这样，我们期望在 $\mathcal{O}(\sqrt{m})$ 次后遍历整个 $x_i$ 的 $\rho$ 形图的环，此时要么我们已经找到了一个非平凡因子，要么我们需要重新执行一遍上述算法。

这个算法的时间复杂度已经很优秀了，但其中包含了较多次数的 $\gcd$ 运算，这实际上会大大拖慢程序的运行速度。

根据相关性质，我们可以考虑把一部分的 $|u - v|$ 乘在一起，即令 $\displaystyle mul = (\prod |u - v|) \bmod n$，然后判断 $\gcd(n, mul)$ 是否为一个非平凡因子。具体地，我们可以考虑倍增 $|i - j|$ 的范围，然后将对应范围内的 $|u - v|$ 乘在一起，经实测当倍增到 $128$ 时停止倍增有最优的运行效率。

这样，我们可以把 $\gcd$ 运算的次数看做一个常数，那么算法的期望时间复杂度即为 $\mathcal{O}(\sqrt{m})$。

------

实际上，$\mathcal{Pollard-Rho}$ 算法的复杂度并没有得到十分严谨的证明，其原因是伪随机函数是否足够均匀还有待商榷。但不可否认的是，算法的运行效率确实非常高，这也让它能够很好地胜任大整数分解的任务。

需要代码实现的读者可以看[这里](https://www.luogu.com.cn/paste/41bansxp)。

------

## 未完待续 ……
