<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ReClouds&#39; Blog</title>
  
  <subtitle>ReClouds 的 OI 之路</subtitle>
  <link href="https://reclouds.github.io/atom.xml" rel="self"/>
  
  <link href="https://reclouds.github.io/"/>
  <updated>2023-01-03T10:50:41.964Z</updated>
  <id>https://reclouds.github.io/</id>
  
  <author>
    <name>ReClouds</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://reclouds.github.io/post/hello-world.html"/>
    <id>https://reclouds.github.io/post/hello-world.html</id>
    <published>2023-01-03T10:50:41.964Z</published>
    <updated>2023-01-03T10:50:41.964Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【题解】CF1423G Growing Flowers 题解</title>
    <link href="https://reclouds.github.io/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1423G%20Growing%20Flowers%20%E9%A2%98%E8%A7%A3.html"/>
    <id>https://reclouds.github.io/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1423G%20Growing%20Flowers%20%E9%A2%98%E8%A7%A3.html</id>
    <published>2022-10-13T14:19:26.000Z</published>
    <updated>2022-10-31T11:06:49.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>给定一个序列，每个位置 $i$ 存在一种颜色 $a_i$，要求支持下列两种操作：</p></blockquote><blockquote><ol><li>给定子段 $[l, r]$ 和颜色 $x$，将该子段所有位置的颜色全部变为 $x$；</li></ol></blockquote><blockquote><ol start="2"><li>给定 $k$，求所有长度为 $k$ 的子段内不同颜色的数量的和。</li></ol></blockquote><blockquote><p>$\mathcal{Data~Range}$：$1 \le n, q \le 10^5$，$1 \le a_i \le 10^9$，$1 \le k \le n$。</p></blockquote><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们发现修改操作只有一种：子段颜色覆盖。那么我们可以考虑用 $\texttt{set}$ 维护颜色段，根据颜色段均摊的结论，这样的时间复杂度是可以接受的。</p><p>那么现在的问题是：求出一个颜色段对答案的贡献。</p><p>乍一看，我们似乎要维护每个位置对每一种 $k$ 的贡献，时间复杂度似乎不太可以接受。</p><p>但实际上我们通过分析，可以发现贡献要么呈一段相等的数的形式，要么呈一段等差数列的形式，并且我们仅需支持单点查询，所以我们可以把贡献差分，那么询问时就仅需求前缀和即可。</p><p>接下来就是具体分析的环节。</p><p>我们钦定在段中，每种颜色第一次出现的位置才会造成实质性的贡献。</p><p>那么对于第一个位置 $pos$，我们考虑计算它对 $k$ 的贡献：</p><p>在包含 $pos$ 的所有长度为 $k$ 的子段中，右端点最右会延伸到 $\min(n, pos + k - 1)$，因为极限情况就是左端点为 $pos$ 的情况，但是右端点又不能超过 $n$。</p><p>假设我们现在已经维护好了 $pos$ 的颜色在 $pos$ 之前的最后一次出现的位置 $pre$（没有则记为 $0$），那么在包含 $pos$ 的所有长度为 $k$ 的子段中，右端点最左会延伸到 $\max(pos, pre + k)$，因为极限情况就是右端点为 $pos$ 的情况，但是左端点又必须在 $pre$ 右侧（否则 $pos$ 的颜色的实质性贡献就不会由 $pos$ 提供）。</p><p>(注意 $pre$ 可以在维护颜色段的同时维护。)</p><p>综上，$pos$ 的贡献即为 $\min(n, pos + k - 1) - \max(pos, pre + k) + 1$。注意 $k$ 的范围为 $[1, n - pos]$，否则 $pos$ 会有负贡献，这是不存在的。</p><p>把贡献拆开，可以发现 $\min$ 和 $\max$ 的部分由于 $k$ 递增，所以贡献是呈一段等差数列和一段相等数列的形式的，差分后可以很方便地用线段树维护。</p><p>那么我们还需要对颜色段中 $pos$ 以后的位置做同样的分析吗？当然不需要。</p><p>我们发现，颜色段中 $pos$ 以后的位置 $pos’$ 的贡献十分简单，因为包含它的子段的左端点必须在 $pos’$ 这个位置上，所以它对所有 $k \in [1, n - pos’ + 1]$ 的贡献均为 $1$。</p><p>稍作分析，可以发现颜色段中 $pos$ 以后的位置对 $k \in [1, n - pos]$ 的总贡献为 $\min(n - pos - k + 1, len - 1)$（其中 $len$ 表示颜色段长度）。由于 $k$ 递增，因此这个部分的贡献仍然呈一段等差数列和一段相等数列的形式，可以继续差分后用线段树维护。</p><p>于是这题就做完了，不过写起来细节还挺多。</p><p>（由于笔者 $1$ 操作的常数过大，所以笔者做了一个数据分治，对于询问次数 $q$ 较小的数据采用了常数较小的、复杂度为 $\mathcal{O}(m\log_2 n + nq)$ 的做法。）</p><p><a href="https://www.luogu.com.cn/record/74729196">代码实现</a></p><hr><h2 id="mathcal-END"><a href="#mathcal-END" class="headerlink" title="$\mathcal{END}$"></a>$\mathcal{END}$</h2>]]></content>
    
    
    <summary type="html">本文为 CF1423G 的题解。</summary>
    
    
    
    <category term="OI" scheme="https://reclouds.github.io/categories/OI/"/>
    
    <category term="数据结构" scheme="https://reclouds.github.io/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="线段树" scheme="https://reclouds.github.io/categories/OI/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
    <category term="题解" scheme="https://reclouds.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】CF1634D Finding Zero 题解</title>
    <link href="https://reclouds.github.io/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1634D%20Finding%20Zero%20%E9%A2%98%E8%A7%A3.html"/>
    <id>https://reclouds.github.io/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1634D%20Finding%20Zero%20%E9%A2%98%E8%A7%A3.html</id>
    <published>2022-10-13T13:48:39.000Z</published>
    <updated>2022-10-31T11:07:08.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>交互库中存在一个非负整数数列 $a_i$。</p></blockquote><blockquote><p>给定数列的长度 $n$，每次可以选择三个不同的位置 $i,j,k$ 进行询问，交互库会返回数列中对应的三个数的极差，即 $\max(a_i, a_j, a_k) - \min(a_i, a_j, a_k)$。</p></blockquote><blockquote><p>现保证数列中恰好存在一个 $0$，请用最多 $n \cdot 2-2$ 次询问求出 $0$ 的位置。</p></blockquote><blockquote><p>回答时可以回答两个位置，只要有一个位置是正确的即可。</p></blockquote><blockquote><p>$\mathcal{Data~Range}$：$t$ 组数据，$1 \le t \le 500$，$4 \le n \le 1 \times 10^3$，$\displaystyle \sum_{i &#x3D; 1}^t n_i \le 3 \times 10^3$。</p></blockquote><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>我们知道，整个序列是非负的，并且恰好存在一个 $0$，说明 $0$ 是数列的最小值。换句话说，$0$ 是数列的极值。</p><p>同时，我们在回答时可以回答两个位置，这启发我们：如果我们已经知道数列中有两个位置分别对应了数列的两个极值（这里特指一个最大值和一个最小值），那么我们回答这两个位置即可。</p><p>所以算法的大致框架就出来了：确定数列的极值位置。</p><hr><p>首先，我们可以先固定两个位置（下文以 $1,n$ 为例），询问它们和其它所有位置 $i$ 的值（即所有的 $\max(a_1, a_n, a_i) - \min(a_1, a_n, a_i)$）。这一步一共用去了 $n-2$ 次询问。</p><p>得到了所有位置的值之后，我们就需要分情况讨论了。</p><p>$\mathcal{A}.$ 所有值中的最大值和最小值相等</p><p>最大值和最小值相等，其实就说明了所有数都相等。</p><p>也就是说，$a_1$ 和 $a_n$ 两个位置有可能直接对应了最大值和最小值，因为无论怎样询问，得到的答案都是 $|a_1 - a_n|$。</p><p>但这是唯一的情况吗？显然不是，因为还存在另外一种情况：</p><p>如果把所有数放在数轴上，发现它们最多只有 $4$ 个本质不同的数（且至少有 $3$ 个本质不同的数），并且 $a_{2 \sim n - 1}$ 这些数关于一个数的位置或者两个数正中间的位置轴对称，那么 $a_1$ 和 $a_n$ 也可能对应了这个对称轴所对应的一个数或者两个数。</p><p>举两个例子（分别对应一个数和两个数做为对称轴的情况）：<br>$$<br>\begin{matrix}<br>a_i: 1,2,0,2,1<br>\<br>a_i: 1,3,0,3,2<br>\end{matrix}<br>$$<br>第一个例子中，$1$ 即为对称轴，并且 $a_1&#x3D;a_n&#x3D;1$，可以发现只出现了 $3$ 个本质不同的数，并且每一个位置的值都相等。</p><p>第二个例子中，$1$ 和 $2$ 正中间的位置即为对称轴，并且有 $a_1 &#x3D; 1,a_n&#x3D;2$，可以发现只出现了 $4$ 个本质不同的数，并且同样可以发现每一个位置的值都相等。</p><p>在这一种情况中，$a_1,a_n$ 并非极值，但是它满足了前提条件 $\mathcal{A}$。然而，单凭前 $n-2$ 次询问并不能区分这两种情况。</p><p>所以这个时候，我们再次拿出两个位置 $2$ 和 $n - 1$，再做 $n - 2$ 次询问得到每个位置的值（因为 $n\ge 4$，所以选择这两个位置不会有问题）。</p><p>这个时候，我们就得继续分情况讨论了。</p><p>$\alpha.$ 所有值中的最大值和最小值仍然相等</p><p>上面我们讨论了，如果两个位置做 $n - 2$ 次询问得到的所有值都相等，那么只会对应上述的两种情况。</p><p>并且，我们可以发现一个十分巧妙的结论：$a_1,a_n$ 和 $a_2,a_{n - 1}$ 这两对数，一定分别对应这两种情况。</p><p>证明：</p><p>如果两个位置分别对应了一个最大值和一个最小值，由于最小值为 $0$ 且只有一个，所以另一对数一定不会对应这种情况。</p><p>如果两个位置分别对应了对称轴所对应的一个或两个数，由于对称轴上不会出现除这两个位置之外的任何位置（否则最小值就为 $0$，由于所有的 $a_i$ 不会全部相等，那么其必然小于最大值），所以另一对数也不会对应这种情况。</p><p>证毕。</p><p>所以，如果我们能区分这两种情况，那么就可以得到极值的两个位置。</p><p>区分它们很简单：如果做 $n - 2$ 次询问后，一对数所得到的值大于另一对得到的值（没有歧义，因为两对数得到的所有值分别是相等的），说明前者是极值的位置，反之说明后者是极值的位置。</p><p>理由很简单：整个序列的极差一定会大于等于子序列的极差，而等于的情况在这里一定不会出现。</p><p>$\beta.$ 所有值中的最大值和最小值不相等</p><p>这里我们也得分情况讨论：</p><ol><li><p>$1,n$ 两个位置对应的是最大值和最小值，而 $2,n - 1$ 两个位置对应了任意两个不属于 $\mathcal{A}-\alpha$ 情况的两个数；</p></li><li><p>$1,n$ 对应的是对称轴所对应的一个或两个数，而 $2,n - 1$ 两个位置对应了两个最大值。</p></li></ol><p>对于第一种情况，我们直接输出 $1,n$ 两个位置即可。</p><p>对于第二种情况，我们找到 $2,n-1$ 两个位置询问 $n - 2$ 次后获得的最大值所对应的位置，这个位置即为 $0$ 所在的位置。</p><p>区分也很简单，我们直接通过 $\mathcal{A}-\alpha$ 情况中得出的结论来区分即可：如果做 $n - 2$ 次询问后，$a_2,a_{n-1}$ 这对数获得的最大值大于 $1,n$ 获得的最大值，那么为情况 $\mathcal{A}-\alpha-2$，否则为情况 $\mathcal{A}-\alpha-1$。</p><p>$\mathcal{B}.$ 所有值中的最大值和最小值不相等</p><p>这个情况就显得简单一些了，因为它没有那么多的分类讨论。</p><p>我们把所有值中的最大值所对应的位置拿出来，可以发现它一定对应了一个极值。我们设这个位置为 $p$。</p><p>接着，我们拿 $1,p$ 这两个位置再询问 $n - 2$ 次，然后分情况讨论。</p><p>$\alpha.$ 所有值中的最大值和最小值相等</p><p>由于 $p$ 已经确定是一个极值了，因此 $1$ 一定也是一个极值，我们回答这两个位置即可。</p><p>$\beta.$ 所有值中的最大值和最小值不相等</p><p>我们再把这个最大值对应的位置拿出来，设其为 $q$，那么 $p,q$ 分别对应了最大值和最小值，我们回答这两个位置即可。</p><hr><p>上述分讨的每一种情况询问次数均为 $n \cdot 2-4$，可以通过本题。</p><p><a href="https://www.luogu.com.cn/record/72660650">代码实现</a></p><hr><h2 id="mathcal-END"><a href="#mathcal-END" class="headerlink" title="$\mathcal{END}$"></a>$\mathcal{END}$</h2>]]></content>
    
    
    <summary type="html">本文为 CF1634D 的题解。</summary>
    
    
    
    <category term="OI" scheme="https://reclouds.github.io/categories/OI/"/>
    
    <category term="交互题" scheme="https://reclouds.github.io/categories/OI/%E4%BA%A4%E4%BA%92%E9%A2%98/"/>
    
    
    <category term="题解" scheme="https://reclouds.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【题解】P5319 [BJOI2019] 奥术神杖 题解</title>
    <link href="https://reclouds.github.io/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5319%20BJOI2019%20%E5%A5%A5%E6%9C%AF%E7%A5%9E%E6%9D%96%20%E9%A2%98%E8%A7%A3.html"/>
    <id>https://reclouds.github.io/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5319%20BJOI2019%20%E5%A5%A5%E6%9C%AF%E7%A5%9E%E6%9D%96%20%E9%A2%98%E8%A7%A3.html</id>
    <published>2022-10-13T13:05:17.000Z</published>
    <updated>2022-10-31T11:06:53.550Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>给定一个长为 $n$ 的字符串 $S$，其每一位为数字 $0\sim 9$ 或一个 $.$ 字符，后者表示该位可以为任何数字。</p></blockquote><blockquote><p>再给定 $m$ 个字符串 $T_i$，每个字符串有其对应的权值 $V_i$。</p></blockquote><blockquote><p>初始时有变量 $\mathcal{Magic} &#x3D; 1$ 和 $\mathcal{Count} &#x3D; 0$。</p></blockquote><blockquote><p>每当 $T_i$ 在 $S$ 中出现一次（即不同位置出现算作多次），我们就将 $\mathcal{Magic}$ 乘上 $V_i$，并将 $\mathcal{Count}$ 加上 $1$。</p></blockquote><blockquote><p>最终的答案为 $\mathcal{Answer} &#x3D; \sqrt[\mathcal{Count}]{\mathcal{Magic}}$。</p></blockquote><blockquote><p>要求找到一种填充字符串内 $.$ 字符的方案，使得 $\mathcal{Answer}$ 最大，并且需要输出一种满足 $\mathcal{Answer}$ 最大的填充字符串的方案。</p></blockquote><blockquote><p>$\mathcal{Data~Range}: 1 \le n, m \le 1501, 1 \le V_i \le 10^9, 1 \le \displaystyle{\sum_{i &#x3D; 1}^m} |T_i| \le 1501$</p></blockquote><hr><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><del>（你真的会高精度开任意次方根吗？）</del></p><p>所以这题显然要在答案的式子上下点功夫。</p><p>和乘积有关的题目，一个好的思路是化乘为加。我们如果把每个 $V_i$ 都求 $\ln$，就可以把 $\mathcal{Magic}$ 由求积转化为求和了，并且这样的转化并不会影响答案之间的大小关系。</p><p>而 $\mathcal{Count}$ 次方根这个部分，可以发现它直接变成了 $\displaystyle \frac{1}{\mathcal{Count}}$，所以原式就化为了 $\displaystyle \frac{\mathcal{Magic}}{\mathcal{Count}}$。</p><p>我们再重新审视一遍 $\mathcal{Magic}$ 和 $\mathcal{Count}$：每次当前者加上一个 $V_i$ 时，后者就会加上一个 $1$，而又因为两者的贡献是呈分数形式的，所以我们需要用到的算法已经很明显了 —— 分数规划。</p><p>考虑分数规划的经典解法，我们二分一个答案 $mid$，那么有：<br>$$<br>\begin{matrix}<br>\dfrac{\displaystyle{\sum_{i &#x3D; 1}^{\mathcal{Count}} V_i}}{\mathcal{Count}} &gt; mid<br>\<br>\displaystyle{\sum_{i &#x3D; 1}^{\mathcal{Count}}} V_i &gt; {\mathcal{Count}} * mid<br>\<br>\displaystyle{\sum_{i &#x3D; 1}^{\mathcal{Count}}} (V_i - mid) &gt; 0<br>\end{matrix}<br>$$</p><p>推导到这里，可以发现，只要给每一个权值减去一个 $mid$，那么这个式子的值和 $\mathcal{Count}$ 的具体值已经没有任何关系了。</p><p>剩下的部分，就是求出左侧式子的最大值，然后和 $0$ 比较了。</p><p>而我们要如何求这个最大值呢？可以发现它和普通的分数规划不太一样：我们无法决定每个贡献的系数是 $0$ 还是 $1$。</p><p>我们再次重新审视一遍这个问题：填充 $S$ 的所有 $.$ 字符，使得出现的所有 $T_i$ 的权值和最大。</p><p>对于这种涉及到了字符串的多模匹配的问题，我们可以考虑用 $\operatorname{AC}$ 自动机来解决。具体地，设 $f_{i, j}$ 表示走到自动机的 $i$ 号节点，同时 $S$ 串已经填完了前 $j$ 个字符，在这种情况之下我们能够得到的最大权值。</p><p>转移很简单，由于自动机具有优美的结构，因此我们仅需每次枚举下一个字符进行转移即可。注意由于我们最终需要输出一个满足要求的字符串，因此转移时需要记录前驱状态和转移时枚举的字符。</p><p>最后一个问题来了：如何处理自动机上每个点的贡献？</p><p>显然，对于一个点，如果它对应了一个 $T_i$，那么在 $\mathcal{Fail}$ 树中以它为根的子树都需要加上它的权值。所以，对于每一个 $mid$，我们利用树上差分重构一遍自动机上每个点的贡献即可。</p><p><a href="https://www.luogu.com.cn/record/72377748">代码实现</a></p><hr><h2 id="mathcal-END"><a href="#mathcal-END" class="headerlink" title="$\mathcal{END}$"></a>$\mathcal{END}$</h2>]]></content>
    
    
    <summary type="html">本文为 P5319 的题解。</summary>
    
    
    
    <category term="OI" scheme="https://reclouds.github.io/categories/OI/"/>
    
    <category term="字符串" scheme="https://reclouds.github.io/categories/OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="AC 自动机" scheme="https://reclouds.github.io/categories/OI/%E5%AD%97%E7%AC%A6%E4%B8%B2/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
    
    <category term="题解" scheme="https://reclouds.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】斯特林的试炼</title>
    <link href="https://reclouds.github.io/post/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%AF%E7%89%B9%E6%9E%97%E7%9A%84%E8%AF%95%E7%82%BC.html"/>
    <id>https://reclouds.github.io/post/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%AF%E7%89%B9%E6%9E%97%E7%9A%84%E8%AF%95%E7%82%BC.html</id>
    <published>2022-10-10T10:55:03.000Z</published>
    <updated>2022-10-31T07:07:49.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于式子较多，为增强直观性，笔者将用 $\displaystyle \binom{n}{m}$ 表示组合数 $\operatorname{C}_n^m$。</p><p>同理，笔者会用如下的形式：</p><p>$$<br>\begin{bmatrix}n \ k\end{bmatrix}<br>$$</p><p>以及：<br>$$<br>\begin{Bmatrix}n \ k\end{Bmatrix}<br>$$<br>分别表示第一类斯特林数 $s(n, k)$ 和第二类斯特林数 $S(n, k)$。</p><p>注意：这些符号的定义下文不会再次提及。</p><p>阅读这篇文章前，您需要较为熟练地掌握组合数、排列数（特别是圆排列）的定义和公式，以及常见的组合恒等式。</p><hr><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="上升幂和下降幂"><a href="#上升幂和下降幂" class="headerlink" title="上升幂和下降幂"></a>上升幂和下降幂</h3><ul><li>定义 $x^{\overline{n}}$ 为 $x$ 的 $n$ 次上升阶乘幂，又称上升幂。它的值等于 $\displaystyle \prod_{i &#x3D; 0}^{n - 1} (x + i)$。</li><li>定义 $x^{\underline{n}}$ 为 $x$ 的 $n$ 次下降阶乘幂，又称下降幂。它的值等于 $\displaystyle \prod_{i &#x3D; 0}^{n - 1} (x - i)$。</li></ul><p>上升幂和下降幂的转换公式（请读者自主完成证明）：<br>$$<br>\begin{matrix}<br>(-x)^{\overline{n}} &#x3D; (-1)^n \cdot x^{\underline{n}}<br>\<br>(-x)^{\underline{n}} &#x3D; (-1)^n \cdot x^{\overline{n}}<br>\end{matrix}<br>$$<br>实际上，上升幂和下降幂与普通幂之间也有转换公式，不过由于公式中存在斯特林数，因此将在下文提及。</p><h3 id="普通生成函数"><a href="#普通生成函数" class="headerlink" title="普通生成函数"></a>普通生成函数</h3><p>通俗的讲，对于一个数列 $a_n$，它的普通生成函数（简称 $\operatorname{OGF}$）为一个多项式：<br>$$<br>f(x) &#x3D; \sum_{i &#x3D; 0}^{\infty} a_i\cdot x^i<br>$$<br>（严谨地讲，$f(x)$ 应该叫做形式幂级数，不过笔者并不了解其确切定义，因此这里用更通俗的方式解释。）</p><p>也就是说，对于多项式 $f(x)$，有 $a_n &#x3D; [x^n]f(x)$。</p><p>如果我们能够得到这个多项式，那么我们也可以从它的系数中获取到这个序列。</p><p>同时，如果我们要对数列间做一些运算（如卷积），也可以通过对这个多项式做运算得到最终的结果。</p><hr><h2 id="第一类斯特林数"><a href="#第一类斯特林数" class="headerlink" title="第一类斯特林数"></a>第一类斯特林数</h2><p>把 $n$ 个互不相同的数分为 $k$ 个圆排列，这样的方案数称为第一类斯特林数，也叫斯特林轮换数。</p><h3 id="递推式"><a href="#递推式" class="headerlink" title="递推式"></a>递推式</h3><p>我们知道，如果在一个长为 $n$ 的圆排列中插入一个数（一共有 $n$ 个位置可以插入），形成的 $n$ 种长为 $n + 1$ 的圆排列是互不相同的，因为它们互相之间不可以通过轮换得到。</p><p>所以，第一类斯特林数有递推公式：<br>$$<br>\begin{bmatrix}n \ k\end{bmatrix} &#x3D; \begin{bmatrix}n - 1 \ k - 1\end{bmatrix} + (n - 1) \cdot \begin{bmatrix}n - 1 \ k\end{bmatrix}<br>$$</p><p>当然，该递推式也存在边界条件：<br>$$<br>\begin{bmatrix}n \ 0\end{bmatrix} &#x3D; [n &#x3D; 0]<br>$$</p><p>如何证明这个递推公式？</p><ul><li>考虑从组合意义的角度入手：加入一个数，要么自己单独构成一个圆排列，要么插入已有的圆排列。前面说过，后者的方案数为 $n - 1$。所以，根据加法原理，即可得到该递推式。</li></ul><p>由于第一类斯特林数不存在通项公式，这个递推式就显得尤为重要了，它将辅助证明下面的诸多结论。</p><h3 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h3><h4 id="1-和阶乘的关系："><a href="#1-和阶乘的关系：" class="headerlink" title="1. 和阶乘的关系："></a>1. 和阶乘的关系：</h4><p>$$<br>n! &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix}<br>$$</p><p>前者实际上是指 $1\sim n$ 的全排列。由于每一种排列中，圆排列的个数是一定的，那么我们可以考虑枚举所有的圆排列个数，把对应的第一类斯特林数相加即为答案。 </p><h4 id="2-和上升幂的关系（上升幂转普通幂）："><a href="#2-和上升幂的关系（上升幂转普通幂）：" class="headerlink" title="2. 和上升幂的关系（上升幂转普通幂）："></a>2. 和上升幂的关系（上升幂转普通幂）：</h4><p>$$<br>x^{\overline{n}} &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix} \cdot x^i<br>$$</p><p>如何证明？</p><div class="note success flat"><div class="tabs" id="证明"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#证明-1">生成函数</button></li><li class="tab"><button type="button" data-href="#证明-2">数学归纳法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="证明-1"><p>考虑构造第一类斯特林数的生成函数：<br>$$<br>f_n(x) &#x3D; \sum_{i &#x3D; 0}^\infty \begin{bmatrix}n \ i\end{bmatrix} \cdot x^i<br>$$<br>证明如下：<br>$$<br>\begin{aligned}<br>&amp;\because  f_n(x) &#x3D; x\cdot f_{n - 1}(x) + (n - 1)\cdot f_{n - 1}(x)<br>\<br>&amp;\therefore f_n(x) &#x3D; (x + n - 1)\cdot f_{n - 1}(x)<br>\<br>&amp;\because f_0(x) &#x3D; 1<br>\<br>&amp;\therefore f_n(x) &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix} \cdot x^i &#x3D; x^{\overline{n}}<br>\end{aligned}<br>$$<br>以上证明过程也说明了：所有 $n$ 相同的第一类斯特林数（也叫第 $n$ 行第一类斯特林数）的生成函数是 $x^{\overline{n}}$。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="证明-2"><p>受生成函数证明过程的启发，我们还可以考虑用数学归纳法证明。</p><p>显然当 $n &#x3D; 0$ 时，原式左右两边相等。</p><p>设当前结论满足 $n &#x3D; m$ 的情况，求证当前结论也满足 $n &#x3D; m + 1$ 的情况。</p><p>问题转化为证明：<br>$$<br>\sum_{i &#x3D; 0}^{n + 1} \begin{bmatrix}n + 1 \ i\end{bmatrix}\cdot x^i &#x3D; (x  + n)\cdot \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix}\cdot x^i<br>$$<br>过程如下：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i &#x3D; 0}^{n + 1} \begin{bmatrix}n + 1 \ i\end{bmatrix}\cdot x^i<br>\<br>&#x3D; &amp;\sum_{i &#x3D; 0}^{n + 1} (\begin{bmatrix}n \ i - 1\end{bmatrix} + n\cdot\begin{bmatrix}n \ i\end{bmatrix})\cdot x^i<br>\<br>&#x3D; &amp;\sum_{i &#x3D; 0}^{n + 1} \begin{bmatrix}n \ i - 1\end{bmatrix}\cdot x^i +  \sum_{i &#x3D; 0}^{n + 1} n\cdot\begin{bmatrix}n \ i\end{bmatrix}\cdot x^i<br>\<br>&#x3D; &amp;\sum_{i &#x3D; 0}^{n} \begin{bmatrix}n \ i\end{bmatrix}\cdot x^{i + 1} +  n \cdot\sum_{i &#x3D; 0}^{n}\begin{bmatrix}n \ i\end{bmatrix}\cdot x^i<br>\<br>&#x3D; &amp;x\cdot\sum_{i &#x3D; 0}^{n} \begin{bmatrix}n \ i\end{bmatrix}\cdot x^{i} +  n \cdot\sum_{i &#x3D; 0}^{n}\begin{bmatrix}n \ i\end{bmatrix}\cdot x^i<br>\<br>&#x3D; &amp;(x + n)\cdot \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix}\cdot x^i<br>\end{aligned}<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><h3 id="同一行第一类斯特林数的求法"><a href="#同一行第一类斯特林数的求法" class="headerlink" title="同一行第一类斯特林数的求法"></a>同一行第一类斯特林数的求法</h3><p><a href="https://www.luogu.com.cn/problem/P5408">模板题</a></p><p>根据递推公式，我们可以得到一个 $\mathcal{O}(n^2)$ 的做法。</p><p>根据上面的结论（第 $n$ 行第一类斯特林数的生成函数是 $x^{\overline{n}}$），我们有 $\mathcal{O}(n \log_2^2 n)$ 的做法：</p><ul><li>上升幂本质上是若干个二项式相乘，所以我们用分治加 $\operatorname{NTT}$ 即可。</li></ul><p>有没有更快的做法？当然有！</p><p>考虑倍增，当前求出了 $x^{\overline{n}}$，要求 $x^{\overline{n\cdot 2}}$。</p><p>因为 $x^{\overline{n \cdot 2}} &#x3D; x^{\overline{n}}\cdot (x + n)^{\overline{n}}$，所以我们只要能够求出 $(x + n)^{\overline{n}}$，就能够做到 $\mathcal{O}(n \log_2 n)$ 了。</p><p>考虑生成函数的展开形式：已知 $\displaystyle f(x) &#x3D; \sum_{i &#x3D; 0}^n a_i\cdot x^i$，要求 $\displaystyle f(x + n) &#x3D; \sum_{i &#x3D; 0}^n a_i\cdot (x + n)^i$。</p><p>我们对后面的这个式子做二项式展开：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i &#x3D; 0}^n a_i\cdot (x + n)^i<br>\<br>&#x3D; &amp;\sum_{i &#x3D; 0}^n a_i\sum_{j &#x3D; 0}^i\displaystyle\binom{i}{j}\cdot x^j\cdot n^{i - j}<br>\<br>&#x3D; &amp;\sum_{i &#x3D; 0}^n a_i\sum_{j &#x3D; 0}^i\frac{i!}{j!\cdot(i - j)!}\cdot x^j\cdot n^{i - j}<br>\<br>&#x3D; &amp;\sum_{j &#x3D; 0}^n\frac{x_j}{j!}\sum_{i &#x3D; j}^n a_i \cdot i!\cdot\frac{n^{i - j}}{(i - j)!}<br>\<br>&#x3D; &amp;\sum_{j &#x3D; 0}^n\frac{x_j}{j!}\sum_{i &#x3D; 0}^{n - j} a_{i + j}\cdot(i + j)!\cdot\frac{n^{i}}{i!}<br>\end{aligned}<br>$$</p><p>这是一个非常典型的差卷积形式，我们可以直接用 $\operatorname{NTT}$ 优化，这样时间复杂度就是 $\mathcal{O}(n \log_2 n)$ 了。</p><p>求出 $(x + n)^{\overline{n}}$ 后，我们再将其和 $x^{\overline{n}}$ 做卷积即可得到 $x^{\overline{n \cdot 2}}$。</p><p>注意要特判奇数的情况，此时还要再乘上一个 $x + n \cdot 2$，直接 $\mathcal{O}(n)$ 乘即可。</p><hr><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul><li><a href="https://www.luogu.com.cn/problem/P4609">P4609 [FJOI2016] 建筑师</a></li></ul><p>题解：</p><div class="note success flat"><p>做组合数学的题，光有推式子能力还不行，还得通过组合意义列出答案的式子。</p><p>例如这道题目，我们要思考的是，如何在其中加入组合意义。</p><p>可以发现，无论是从左边还是从右边，都一定会看到最高的楼。</p><p>然后，我们如果设 $\lambda$ 为能够看到的楼，$.$ 为不能够看到的楼，$H$ 为最高的楼，那么建筑一定是这种形式：<br>$$<br>\lambda….\lambda..\lambda..\lambda…H.\lambda…..\lambda..\lambda<br>$$<br>我们来从左侧的角度解释一下这个图的一些细节（右侧同理）：</p><ul><li>$H$ 左侧的 $\lambda$ 数量为 $A - 1$；</li><li>左侧要么不存在 $\lambda$，要么第一个字符即为 $\lambda$，每一个 $\lambda$ 的右边存在若干个 $.$，这个 $\lambda$ 的高度高于这些 $.$；</li><li>对于左侧的一个 $\lambda$，右侧的 $.$ 顺序随意。</li></ul><p>“顺序随意” 给了我们一定的启发，如果耐心把式子列出来，可以发现：如果我们把一个 $\lambda$ 和其右侧的 $m$ 个 $.$ 看作一个整体，那么由于一共有 $(m - 1)!$ 种排列方式。</p><p>如果你对排列数十分敏感，可以一眼看出——这就是圆排列。</p><p>圆排列！我们能想到什么？第一类斯特林数！</p><p>所以，我们只要在 $n - 1$ 个数中选出 $A + B - 2$ 个圆排列，并任选 $A-1$ 个放在 $H$ 的左边，$B - 1$ 个放在 $H$ 的右边，即为一种方案。</p><p>那么，答案就呼之欲出了：<br>$$<br>\begin{bmatrix}n - 1 \ A + B - 2\end{bmatrix} \cdot \displaystyle\binom{A + B - 2}{A - 1}<br>$$<br>直接预处理即可，复杂度在可承受的范围之内。</p></div><hr><h2 id="第二类斯特林数"><a href="#第二类斯特林数" class="headerlink" title="第二类斯特林数"></a>第二类斯特林数</h2><p>把 $n$ 个互不相同的数划分为 $k$ 个互不区分、互不相交的集合，这样的方案数称为第二类斯特林数。</p><p>第二类斯特林数相对于第一类的用处会更加广泛。</p><hr><h3 id="递推式-1"><a href="#递推式-1" class="headerlink" title="递推式"></a>递推式</h3><p>$$<br>\begin{Bmatrix}n \ k\end{Bmatrix} &#x3D; \begin{Bmatrix}n - 1 \ k - 1\end{Bmatrix} + k\cdot \begin{Bmatrix}n - 1 \ k\end{Bmatrix}<br>$$</p><p>还是考虑从组合意义去证明：加入一个数，要么自己单独构成一个集合，要么加入已有的 $k$ 个集合。</p><p>边界条件同样是：<br>$$<br>\begin{Bmatrix}n \ 0\end{Bmatrix} &#x3D; [n &#x3D; 0]<br>$$</p><h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><p>第二类斯特林数是存在通项公式的：<br>$$<br>\begin{Bmatrix}n \ k\end{Bmatrix} &#x3D; \frac{1}{k!}\cdot\sum_{i &#x3D; 0}^k(-1)^i\cdot\displaystyle\binom{k}{i} \cdot(k - i)^n &#x3D; \sum_{i &#x3D; 0}^k \frac{(-1)^i}{i!} \cdot \frac{(k - i)^n}{(k - i)!} &#x3D; \sum_{i &#x3D; 0}^k\frac{(-1)^{k - i}}{(k - i)!} \cdot \frac{i^n}{i!}<br>$$<br>（上面把推式子可能会用到的三种形式都写出来了。）</p><p>证明：</p><div class="note success flat"><p>设 $n$ 个互不相同的数划分为 $k$ 个互不相同的集合的方案数为 $f_k, g_k$，前者允许空集，后者不允许空集。</p><p>那么有：<br>$$<br>\begin{matrix}<br>f_k &#x3D; k^n<br>\<br>\displaystyle f_k &#x3D; \sum_{i &#x3D; 0}^k\displaystyle\binom{k}{i}\cdot g_i<br>\end{matrix}<br>$$<br>考虑二项式反演：<br>$$<br>g_k &#x3D; \sum_{i &#x3D; 0}^k (-1)^{k - i}\cdot\displaystyle\binom{k}{i}\cdot f_i &#x3D; \sum_{i &#x3D; 0}^k(-1)^i\cdot\displaystyle\binom{k}{i}\cdot (k - i)^n<br>$$<br>由于 $g_k$ 在统计过程中，集合之间相互区分，所以：</p><p>$$<br>\begin{Bmatrix}n \ k\end{Bmatrix} &#x3D; \frac{g_k}{k!} &#x3D; \frac{1}{k!}\cdot\sum_{i &#x3D; 0}^k(-1)^i\cdot\displaystyle\binom{k}{i}\cdot (k - i)^n<br>$$</p></div><h3 id="常用公式-1"><a href="#常用公式-1" class="headerlink" title="常用公式"></a>常用公式</h3><h4 id="和下降幂的关系（普通幂转下降幂）："><a href="#和下降幂的关系（普通幂转下降幂）：" class="headerlink" title="和下降幂的关系（普通幂转下降幂）："></a>和下降幂的关系（普通幂转下降幂）：</h4><p>$$<br>x^n &#x3D; \sum_{i &#x3D; 0}^x \displaystyle\binom{x}{i}\cdot\begin{Bmatrix}n \ i\end{Bmatrix}\cdot i! &#x3D; \sum_{i &#x3D; 0}^n \begin{Bmatrix}n \ i\end{Bmatrix}\cdot x^{\underline{i}}<br>$$</p><p>证明：</p><ul><li>考虑组合意义，等式左侧即为 $n$ 个互不相同的数划分为 $x$ 个互不相同的可空集合的方案数，等式右侧即选出 $i$ 个集合强制非空的方案数。</li></ul><p>当然，你也可以考虑用上面的数学归纳法证明，这里就留给读者当作练习吧。</p><h3 id="同一行第二类斯特林数的求法"><a href="#同一行第二类斯特林数的求法" class="headerlink" title="同一行第二类斯特林数的求法"></a>同一行第二类斯特林数的求法</h3><p><a href="https://www.luogu.com.cn/problem/P5395">模板题</a></p><p>其实非常简单，我们再一次观察通项公式：<br>$$<br>\begin{Bmatrix}n \ k\end{Bmatrix} &#x3D; \sum_{i &#x3D; 0}^k \frac{(-1)^i}{i!} \cdot \frac{(k - i)^n}{(k - i)!}<br>$$<br>可以发现这就是一个典型的卷积形式，用 $\operatorname{NTT}$ 优化即可。</p><hr><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><ul><li>BZOJ5093 图的价值</li></ul><p>题意：</p><blockquote><p>“简单无向图” 是指无重边、无自环的无向图（不一定连通）。</p></blockquote><blockquote><p>一个带标号的图的价值定义为每个点度数的 $k$ 次方的和。</p></blockquote><blockquote><p>给定 $n$ 和 $k$，请计算所有 $n$ 个点的带标号的简单无向图的价值之和。</p></blockquote><blockquote><p>答案对 $998244353$ 取模。</p></blockquote><blockquote><p>$\mathcal{Data~Range}$：$1 \le n \le 10^9, 1\le k\le 2\times 10^5$。</p></blockquote><p>题解：</p><div class="note success flat"><p>显然每个点对答案的贡献是相同的，所以我们只需要算出一个点对答案的贡献，最后乘上 $n$ 即可。</p><p>我们枚举一个点的度数，那么有：<br>$$<br>\mathcal{Answer} &#x3D;  n \cdot 2^{\binom{n - 1}{2}}\cdot \sum_{i &#x3D; 0}^{n - 1}i^k\cdot\displaystyle\binom{n - 1}{i}<br>$$<br>这个时候，如果只用一般的方法，大概率会无从下手。</p><p>回顾普通幂转化为第二类斯特林数的公式，我们可以得到：<br>$$<br>\begin{aligned}<br>\mathcal{Answer} &amp;&#x3D; n \cdot 2^{\binom{n - 1}{2}} \cdot\sum_{i &#x3D; 0}^{n - 1}i^k\cdot\displaystyle\binom{n - 1}{i}<br>\<br>&amp;&#x3D; n \cdot 2^{\binom{n - 1}{2}} \cdot\sum_{i &#x3D; 0}^{n - 1}\displaystyle\binom{n - 1}{i} \sum_{j &#x3D; 0}^{\min(i, k)}\displaystyle\binom{i}{j}\cdot \begin{Bmatrix}k \ j\end{Bmatrix}\cdot j!<br>\<br>&amp;&#x3D;n \cdot 2^{\binom{n - 1}{2}}\cdot \sum_{j &#x3D; 0}^{\min(n - 1, k)} \begin{Bmatrix}k \ j\end{Bmatrix}\cdot j! \sum_{i &#x3D; j}^{n - 1} \displaystyle\binom{n - 1}{i}\cdot\displaystyle\binom{i}{j}<br>\<br>&amp;&#x3D; n \cdot 2^{\binom{n - 1}{2}}\cdot \sum_{j &#x3D; 0}^{\min(n - 1, k)} \begin{Bmatrix}k \ j\end{Bmatrix}\cdot j! \cdot\displaystyle\binom{n - 1}{j} \sum_{i &#x3D; j}^{n - 1} \displaystyle\binom{n - j - 1}{i - j}<br>\<br>&amp;&#x3D; n \cdot 2^{\binom{n - 1}{2}}\cdot \sum_{j &#x3D; 0}^{\min(n - 1, k)} \begin{Bmatrix}k \ j\end{Bmatrix}\cdot j! \cdot\displaystyle\binom{n - 1}{j} \sum_{i &#x3D; 0}^{n - j - 1} \displaystyle\binom{n - j - 1}{i}<br>\<br>&amp;&#x3D; n \cdot 2^{\binom{n - 1}{2}} \cdot\sum_{j &#x3D; 0}^{\min(n - 1, k)} \begin{Bmatrix}k \ j\end{Bmatrix}\cdot j! \cdot\displaystyle\binom{n - 1}{j}\cdot 2^{n - j - 1}<br>\end{aligned}<br>$$<br>这样就做完了。</p></div><hr><h2 id="斯特林反演"><a href="#斯特林反演" class="headerlink" title="斯特林反演"></a>斯特林反演</h2><h3 id="常用公式-2"><a href="#常用公式-2" class="headerlink" title="常用公式"></a>常用公式</h3><p>在前面的学习中，我们知道有如下两个等式：<br>$$<br>\begin{matrix}<br>(-x)^{\overline{n}} &#x3D; (-1)^n\cdot x^{\underline{n}}<br>\<br>\displaystyle x^{\overline{n}} &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix}\cdot x^i<br>\end{matrix}<br>$$<br>那么有：<br>$$<br>(-x)^{\overline{n}} &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix}\cdot (-x)^i<br>$$<br>即：<br>$$<br>(-1)^n\cdot x^{\underline{n}} &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix}\cdot (-1)^i \cdot x^i<br>$$<br>所以有：<br>$$<br>x^{\underline{n}} &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix} \cdot(-1)^{n - i}\cdot x^i<br>$$<br>类似的，我们可以由如下两个公式：<br>$$<br>\begin{matrix}<br>(-x)^{\underline{n}} &#x3D; (-1)^n\cdot x^{\overline{n}}<br>\<br>\displaystyle x^n &#x3D; \sum_{i &#x3D; 0}^n \begin{Bmatrix}n \ i\end{Bmatrix}\cdot x^{\underline{i}}<br>\end{matrix}<br>$$<br>推出如下的公式：<br>$$<br>x^n &#x3D; \sum_{i &#x3D; 0}^n \begin{Bmatrix}n \ i\end{Bmatrix}\cdot (-1)^{n - i}\cdot x^{\overline{i}}<br>$$<br>请读者自行推导。</p><p>总结一下，我们已经得到了所有的六个上升幂、下降幂和普通幂之间的转换公式：<br>$$<br>\begin{matrix}<br>(-x)^{\overline{n}} &#x3D; (-1)^n\cdot x^{\underline{n}}<br>\<br>(-x)^{\underline{n}} &#x3D; (-1)^n\cdot x^{\overline{n}}<br>\<br>\displaystyle x^{\overline{n}} &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix}\cdot x^i<br>\<br>\displaystyle x^n &#x3D; \sum_{i &#x3D; 0}^n \begin{Bmatrix}n \ i\end{Bmatrix}\cdot x^{\underline{i}}<br>\<br>\displaystyle x^{\underline{n}} &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix}\cdot (-1)^{n - i}\cdot x^i<br>\<br>\displaystyle x^n &#x3D; \sum_{i &#x3D; 0}^n \begin{Bmatrix}n \ i\end{Bmatrix}\cdot (-1)^{n - i}\cdot x^{\overline{i}}<br>\end{matrix}<br>$$<br>下文有可能会分别称它们为公式一 ～ 公式六。</p><p>如果我们将公式三代入公式六，可以得到：<br>$$<br>\begin{aligned}<br>x^n &amp;&#x3D; \sum_{i &#x3D; 0}^n \begin{Bmatrix}n \ i\end{Bmatrix}\cdot (-1)^{n - i}\cdot x^{\overline{i}}<br>\<br>&amp;&#x3D; \sum_{i &#x3D; 0}^n \begin{Bmatrix}n \ i\end{Bmatrix}\cdot (-1)^{n - i}\sum_{j &#x3D; 0}^i<br>\begin{bmatrix}i \ j\end{bmatrix}\cdot x^j<br>\<br>&amp;&#x3D; \sum_{j &#x3D; 0}^nx^j\sum_{i &#x3D; j}^n\begin{Bmatrix}n \ i\end{Bmatrix}\cdot \begin{bmatrix}i \ j\end{bmatrix}\cdot (-1)^{n - i}<br>\end{aligned}<br>$$<br>可以发现有：<br>$$<br>\sum_{i &#x3D; j}^n\begin{Bmatrix}n \ i\end{Bmatrix}\cdot \begin{bmatrix}i \ j\end{bmatrix}\cdot (-1)^{n - i} &#x3D; [j &#x3D; n]<br>$$<br>类似地，将公式四代入公式五也可以得到十分类似的结果，这里就把结论摆出来了：<br>$$<br>\sum_{i &#x3D; j}^n\begin{bmatrix}n \ i\end{bmatrix}\cdot \begin{Bmatrix}i \ j\end{Bmatrix}\cdot (-1)^{n - i} &#x3D; [j &#x3D; n]<br>$$<br>这俩公式合称反转公式。</p><p>当 $j &#x3D; 1$ 时有：<br>$$<br>\sum_{i &#x3D; 1}^n(-1)^{n - 1}\cdot(i - 1)!\cdot\begin{Bmatrix}n \ i\end{Bmatrix} &#x3D; [n &#x3D; 1]<br>$$<br>这个公式在斯特林反演中会经常用到。</p><p>由反转公式，我们就可以得到斯特林反演的一般形式：</p><p>$$<br>\begin{matrix}<br>\displaystyle f_n &#x3D; \sum_{i &#x3D; 0}^n \begin{bmatrix}n \ i\end{bmatrix}\cdot g_i<br>\<br>\Downarrow<br>\<br>\displaystyle g_n &#x3D; \sum_{i &#x3D; 0}^n(-1)^{n -i}\cdot \begin{Bmatrix}n \ i\end{Bmatrix} \cdot f_i<br>\end{matrix}<br>$$</p><p>和</p><p>$$<br>\begin{matrix}<br>\displaystyle f_n &#x3D; \sum_{i &#x3D; 0}^n \begin{Bmatrix}n \ i\end{Bmatrix}\cdot g_i<br>\<br>\Downarrow<br>\<br>\displaystyle g_n &#x3D; \sum_{i &#x3D; 0}^n(-1)^{n -i}\cdot \begin{bmatrix}n \ i\end{bmatrix} \cdot f_i<br>\end{matrix}<br>$$</p><p>这个形式会显得有许些亲切感，因为它便是反演最标准的形式。</p><hr><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><ul><li><a href="https://hydro.ac/d/bzoj/p/4671">BZOJ4671 异或图</a></li></ul><p>题解：</p><div class="note success flat"><p>直接判连通并不好入手。相反，强制不联通却简单得多。</p><p>考虑容斥，设 $f_i$ 为把 $n$ 个点划分为 $i$ 个互相独立且互不相交的点集的方案数，$g_i$ 为图中恰好有 $i$ 个连通块的方案数。</p><p>那么对于 $g_j$，它对 $f_i$ 的贡献即为第二类斯特林数：<br>$$<br>\begin{Bmatrix}j \ i\end{Bmatrix}<br>$$<br>因为 $g_j$ 中的 $j$ 个连通块互不相同，同时 $f_i$ 中的 $i$ 个点集又不考虑顺序，这恰好满足了第二类斯特林数的要求。</p><p>即：<br>$$<br>f_i &#x3D; \sum_{j &#x3D; i}^n \begin{Bmatrix}j \ i\end{Bmatrix}\cdot g_j<br>$$<br>反演一下就有：<br>$$<br>g_i &#x3D; \sum_{j &#x3D; i}^n(-1)^{j - i}\cdot\begin{bmatrix}j \ i\end{bmatrix}\cdot f_j<br>$$<br>依照题意，现在我们只需求出 $\displaystyle g_1 &#x3D; \sum_{j &#x3D; 1}^n (-1)^{j - 1}\cdot(j - 1)!\cdot f_j$，那么最大的问题是求 $f_j$。</p><p>首先我们可以枚举子集划分（时间复杂度为贝尔数级别，不会超时），然后我们强制让两个点集之间不连任何一条边。</p><p>由于一条边的选择情况取决于包含这条边的图的选择情况，因此对于一条横跨两个点集的边 $(u, v)$，我们设包含它的图为 $G’<em>{1\sim m}$，同时设每个图的选择情况为 $x</em>{1\sim m}$（$0$ 表示不选，$1$ 表示选），那么我们可以列出方程：<br>$$<br>\texttt{xor}_{i &#x3D; 1}^m x_i &#x3D; 0<br>$$<br>枚举完每条边之后，我们可以得到一个异或方程组，那么解的数量就是这个子集划分对 $f_j$ 的贡献。</p><p>这是一个经典问题：我们只要把方程转化为二进制数插入线性基，再统计有多少个位置等于 $0$ 即可。设这个值为 $cnt$，那么我们要求的答案就是 $2^{cnt}$。</p></div><hr><ul><li><a href="https://www.luogu.com.cn/problem/CF961G">CF961G Partitions</a></li></ul><p>题解：</p><div class="note success flat"><div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">组合意义</button></li><li class="tab"><button type="button" data-href="#题解-2">代数推导</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><p>我们从组合意义思考一下，集合大小的本质是什么？不就是集合里的每一个数都贡献 $1$ 吗！</p><p>所以说，还是考虑计算单个物品 $i$ 的贡献：</p><p>首先，总划分方案数为：<br>$$<br>\begin{Bmatrix}n \ k\end{Bmatrix}<br>$$<br>每个方案中，自己都会对自己造成 $1$ 的贡献。</p><p>其次，对于其它的每一个物品 $j$，抛开这个物品 $j$ 不谈，我们把剩下的 $n - 1$ 个物品分成 $k$ 组，再把物品 $j$ 加入到 $i$ 所在的组内，这样 $j$ 就对 $i$ 造成了 $1$ 的贡献。这样的方案数为：<br>$$<br>\begin{Bmatrix}n - 1\ k\end{Bmatrix}<br>$$<br>所以单个物品的贡献为：<br>$$<br>\begin{Bmatrix}n \ k\end{Bmatrix} + (n - 1)\cdot\begin{Bmatrix}n - 1 \ k\end{Bmatrix}<br>$$<br>根据第二类斯特林数的通项公式对该式子求值即可。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="题解-2"><p>当然，你也可以尝试代数推导。</p><p>抛开 $w_i$ 不谈，可以发现单个物品的贡献是一定的，所以我们只要把 $w_i$ 求和，乘上单个物品的贡献 $\delta$ 即可。</p><p>现在考虑计算 $\delta$：<br>$$<br>\begin{aligned}<br>\delta &#x3D;&amp;\sum_{i &#x3D; 1}^n i \cdot\displaystyle\binom{n - 1}{i - 1} \cdot\begin{Bmatrix}n - i \ k - 1\end{Bmatrix}<br>\<br>&#x3D;&amp;\sum_{i &#x3D; 1}^n i \cdot\displaystyle\binom{n - 1}{i - 1} \sum_{j &#x3D; 0}^{k - 1}\frac{(-1)^{k - j - 1}}{(k - j - 1)!}\cdot\frac{j^{n - i}}{j!}<br>\<br>&#x3D;&amp;\sum_{j &#x3D; 0}^{k - 1} \frac{(-1)^{k - j - 1}}{(k - j - 1)! \cdot j!}\sum_{i &#x3D; 1}^ni \cdot j^{n - i}\cdot \displaystyle\binom{n - 1}{i - 1}<br>\end{aligned}<br>$$<br>前面的式子没有什么问题，考虑如何求后面的式子：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i &#x3D; 1}^ni \cdot j^{n - i}\cdot \displaystyle\binom{n - 1}{i - 1}<br>\<br>&#x3D;&amp;\sum_{i &#x3D; 1}^n(i - 1 + 1) \cdot j^{n - i}\cdot \displaystyle\binom{n - 1}{i - 1}<br>\<br>&#x3D;&amp;\sum_{i &#x3D; 1}^n(i - 1)\cdot j^{n - i}\cdot\displaystyle\binom{n - 1}{i - 1} + \sum_{i &#x3D; 1}^nj^{n - i}\cdot\displaystyle\binom{n - 1}{i - 1}<br>\<br>&#x3D;&amp;\sum_{i &#x3D; 1}^n(i - 1)\cdot j^{n - i}\cdot\displaystyle\binom{n - 1}{i - 1} + (j + 1)^{n - 1}<br>\<br>&#x3D;&amp;(n - 1)\cdot\sum_{i &#x3D; 1}^n j^{n - i}\cdot\displaystyle\binom{n - 2}{i - 2} + (j + 1)^{n - 1}<br>\<br>&#x3D;&amp;(n - 1)\cdot(j + 1)^{n - 2} + (j + 1)^{n - 1}<br>\<br>&#x3D;&amp;(j + 1)^{n - 2}\cdot(n + j)<br>\end{aligned}<br>$$<br>这样就做完了。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></div><hr><h2 id="mathcal-END"><a href="#mathcal-END" class="headerlink" title="$\mathcal{END}$"></a>$\mathcal{END}$</h2>]]></content>
    
    
    <summary type="html">本文将会讲解第一类斯特林数和第二类斯特林数的定义与性质。</summary>
    
    
    
    <category term="OI" scheme="https://reclouds.github.io/categories/OI/"/>
    
    <category term="数学" scheme="https://reclouds.github.io/categories/OI/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="组合数学" scheme="https://reclouds.github.io/categories/OI/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
    <category term="斯特林数" scheme="https://reclouds.github.io/categories/OI/%E6%95%B0%E5%AD%A6/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0/"/>
    
    
    <category term="学习笔记" scheme="https://reclouds.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
